<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>广来这周在做什么 009</title>
      <link href="/what-is-guanglai-doing-this-week-009/"/>
      <url>/what-is-guanglai-doing-this-week-009/</url>
      
        <content type="html"><![CDATA[<p>这里是广来这周在做什么第九期。这周更多在折腾 VPS，我也没能想到这周花了这么多的时间在 VPS 上，搭建了两个自建服务, linkding 和 memos。基本走通了 docker 部署&#x2F;Web 应用部署，ngnix 反代，SSL 证书，和 cloudflare 域名解析。折腾下来，对部署的事情也基本清楚了。</p><span id="more"></span><h2 id="折腾-VPS"><a href="#折腾-VPS" class="headerlink" title="折腾 VPS"></a>折腾 VPS</h2><p>这周折腾 VPS 一个比较主要的原因是在 <code>linux.do</code> 这个网站上看到了 <code>claw.cloud</code> 在促销便宜的 VPS，价格是首年 7$，续费是每月 3$，也就是每年 36$，配置的话 1C1G 20G硬盘, 500GB 流量，相较于其他云厂商已经是非常便宜的了。买了之后实际上什么也没做，就做了下简单配置放在那边放了一个多星期，这周觉得不去搭建点什么实在是过于浪费了。</p><p><img data-src="https://aliyun-oss-guanglai-me.oss-ap-southeast-1.aliyuncs.com/picgo/20250127042638.png" alt="claw cloud 首年 7 刀的 VPS 配置"></p><p>于是，在 GitHub 上看到了 <a href="https://linkding.link/">linkding | linkding</a> 这个项目之后，就立刻尝试去搭建了一下。服务搭建使用 docker 并不费力，问题在于我之前从没用过 ngnix，也没申请过 SSL 证书。但是，现在是有 AI 的帮助的，心智负担很低，我就在对话的帮助下，一边基于自己的理解，一边动手实际操作。基本上也没有出现过很麻烦的问题，就很顺利的处理好了。最终的成果就是我有了一个独立域名的，通过 https 访问的，独立部署的个人书签管理网站。</p><p>同样的，看到有网友推荐 <a href="https://github.com/usememos/memos">memos</a> 之后，我也同样尝试搭建了一下。这次比 linkding 搭建更快，毕竟有了前面的尝试，基本走通了流程。再尝试就没什么问题了。后续觉得每次都是 copy &amp; paste 有些麻烦，就把自己记录的笔记发给 AI，总结成了可以直接执行的 nignx 反代脚本，不过我还没有第三次尝试使用脚本配置。如果还会再自建服务，我会尝试测试下脚本运行是否符合预期。</p><h2 id="VPS-怎么做安全防护呢？"><a href="#VPS-怎么做安全防护呢？" class="headerlink" title="VPS 怎么做安全防护呢？"></a>VPS 怎么做安全防护呢？</h2><p>以后我可能会写一篇比较全的我最近折腾 VPS 的经历，大致列一下我做了哪些工作来保护我的 VPS 的。</p><p>首先，我是没有安装可视化面板之类的辅助安装工具的。主要通过 ssh 登录到 VPS，apt 安装软件，docker 拉取启动 Web 服务，systemd 管理 VPS 某些后台守护进程服务这么一套手动流程的。</p><ol><li>创建非 root 用户，后续的所有操作都基于非 root 用户操作。</li><li>禁用 ssh root 登录，修改 ssh 默认 22 端口到其他随机端口。</li><li>通过脚本防止 ssh 暴力破解。后续了解到有软件可以防止 ssh 暴力破解，不过没有尝试。</li><li>通过 ufw 防火墙，只放开 80、443 和 ssh 端口，其他端口一概不允许访问。</li><li>docker 启动服务时，端口映射增加本地回环地址（127.0.0.1）。如果不在域名映射命令前增加，那么 docker 会修改 iptables，允许通过 ip 加端口的形式访问 Web 服务。因为我已经配置了域名访问，放开 ip 加端口访问，增加风险，没有必要。</li></ol><p>我目前就只做了上面这些工作，不过因为我的域名是托管在 cloudflare，默认就提供了缓存和防御之类的能力，只要 ip 地址不暴露，被攻击的可能性也就比较低了，谢谢 cloudflare 赛博菩萨。</p><h2 id="Rime-输入法"><a href="#Rime-输入法" class="headerlink" title="Rime 输入法"></a>Rime 输入法</h2><p>周日在家，升级了下 Rime 输入法，macOS 上的名称是 Squirrel，升级之后就出了问题，索性卸载重装。之前听过说【<a href="https://dvel.me/posts/rime-ice/">雾凇拼音</a>】这 Rime 输入法配置方案，但是一直也懒得再去配置新的输入法方案，毕竟现有的配置已经足够我日常使用了，也没有出现需要提升的部分。</p><p>说回【雾凇拼音】，花了一点时间，弄好了。fork 了一份【雾凇拼音】的配置方案。把原來的配置，squirre.custom.yaml，default.custom.yaml 和 installation.yaml 配置到新的配置方案中，合并了原有的用戶词典，现在基本用起來感觉就是新的输入法。非常推荐雾凇拼音。</p><p>刚配置好，就又看到有网友推荐基于雾凇拼音修改的<a href="https://linux.do/t/topic/348495/5?u=knothhe">白霜拼音</a>。理由是「雾凇词库里的词比较全但也不是非常全，主要的问题是字频和词频不太对，废词有点多，于是重新制作。」算了，暂时不折腾了，先使用一段时间，感觉不够好再换。够用就好了。</p><h2 id="自建服务"><a href="#自建服务" class="headerlink" title="自建服务"></a>自建服务</h2><p>说回自建服务 linkding 和 memos 我使用体验非常不错，而且是自建服务，并不担心跑路，只要 VPS 不跑路就可以。不过也因为担心 VPS 跑路，后面我在考虑使用家庭服务器，定时部分服务器上的应用数据。不过有网友说 memos 的开发者经常会做出 breaking change，以至于第三方软件都固定了 memos，这点是我比较担心的部分。</p><p><img data-src="https://aliyun-oss-guanglai-me.oss-ap-southeast-1.aliyuncs.com/picgo/20250127045520.png" alt="memos 使用界面"><br><img data-src="https://aliyun-oss-guanglai-me.oss-ap-southeast-1.aliyuncs.com/picgo/20250127045659.png" alt="linkding 使用界面"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这周主要折腾的事情就是 VPS 了，这次折腾了一次 VPS，对 VPS 的各种使用也基本没什么疑问了，剩下的就是有需求，实际去操作就好。其实本来这周我是有想要自己写一个类似 linkding 的个人书签管理服务的，但是奈何在看到 linkding 基本上把我想要做的事情都做完了之后，瞬间就止步了，转头去自建折腾 VPS 去了。</p><p>以上就是我这周在做的事情，让我们下一期见。</p>]]></content>
      
      
      <categories>
          
          <category> Weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广来这周在做什么 008</title>
      <link href="/what-is-guanglai-doing-this-week-008/"/>
      <url>/what-is-guanglai-doing-this-week-008/</url>
      
        <content type="html"><![CDATA[<p>这里是广来这周在做什么的第八期。这周和我的外甥女，以及一个朋友一起去了上海迪士尼游玩。其他时间更多就是打法了时间，陷入了世界无意义，对这个世界无语的状态阶段。这周毫无所获，白白空度。</p><span id="more"></span><h2 id="上海迪士尼"><a href="#上海迪士尼" class="headerlink" title="上海迪士尼"></a>上海迪士尼</h2><p><img data-src="https://aliyun-oss-guanglai-me.oss-ap-southeast-1.aliyuncs.com/picgo/250117disney-01.jpg" alt="迪士尼大门"><br><img data-src="https://aliyun-oss-guanglai-me.oss-ap-southeast-1.aliyuncs.com/picgo/250117disney-02.jpg" alt="晚上的奇幻童话城堡"></p><p>总算还是去了上海迪士尼。</p><p>毕竟在上海也生活有几年了，大概在半年前就有想法想要去一次上海迪士尼了。也是半年多之前，我开始尝试网络寻找对象。陆陆续续线下接触过一些异性，其实很想说，如果真的能够称为男女朋友，还是很想一起去一次迪士尼的。不过很遗憾，半年多过去了，我仍然是单身一个人。甚至这段时间我已经不再主动和异性接触，识图和对方沟通了解，尝试恋爱脱单。我现在仍然会想要继续和异性接触，尝试恋爱的可能性，但是现在，此刻不行。我觉得我还没有准备好，再过一段时间吧。</p><p>说回上海迪士尼，我们是上午九点多，接近十点从我住的地方，她们则是从我附近的酒店里，一起出发去往迪士尼的。从我住的地方到迪士尼大概要花费一个半小时，我也最终差不多在十一点多入园迪士尼了。这趟游玩最大的感受就是排队了，也有因为我们玩的大都是热门的项目的原因吧。最终只玩了是【小飞象】、【疯狂动物城】、【飞越地平线】三个项目加上晚上八点的【奇梦之光幻影秀】光影烟花，总排队时间在五小时以上。游玩体验还算不错，只是排队实在要人老命，尤其打工人的腰实在是受不住了。</p><p>我这次去玩几乎没做攻略，我大概是想要随行人员做些攻略，我就可以轻松一些。以至于买票都亏了大好几百。我的外甥女是大学生，但是我在迪士尼的官方 APP 上买票，完全没有发现学生票，回来之后，尝试在小红书上搜索了一下，才发现原来美团之类的第三方售票平台上，是有大学生票在售卖的，血亏。以及早鸟票虽然便宜 60，但是不能退改。直接买票的话，是有 100 餐抵，而且是可以改期到附近两天的。这次我们还是有尝试在迪士尼吃饭的，虽然确实完全没有必要。这次之后再去哪里游玩，我一定做好详细计划，随行人员的计划还是先不去考虑，做完攻略再互相商量就好，至少，不能再想这次买票，血亏啊。</p><p>【疯狂动物城】、【飞越地平线】体感还是非常不错的，真实性很强，如果不排队就更好了。以后如果有机会，等我恋爱脱单了，再来一次吧。虽然这次在游玩结束之后，我直接说了大概不会再来一次了，迪士尼的票实在太过于贵了，我这次买票还买得相当得贵，以至于我完全不想公开说花费多少<code>:(</code>。</p><h2 id="人生的意义"><a href="#人生的意义" class="headerlink" title="人生的意义"></a>人生的意义</h2><p><img data-src="https://aliyun-oss-guanglai-me.oss-ap-southeast-1.aliyuncs.com/picgo/biaodayu250117.PNG" alt="表达欲"></p><p>我这一周心情多少有些低落，完全不想做些什么事情，没有创造欲，表达欲。下周我就能找到了吗？</p><p>我一直以来都觉得人生没什么意义，不去想的时候到还好，真的陷入这种情绪的时候，就非常虚无。通常以来，我都是去做些事情什么去克服这种虚无感的，无论是玩游戏，看文章，看视频还是做些什么其他事情好。当然，看视频一般会加重这种虚无感，因为在荒废时间。我也明白能够平平淡淡过完普通的人生就已经很不容易了，但是还是会想要跟多。想做的事情很多，能力却很小，以至于有时间，却什么都不去做。事情太多，想做事情，选择不了做什么事情，于是什么都不去做。这就是我一直以来循环的人生阶段。</p><h2 id="我想要做些什么呢"><a href="#我想要做些什么呢" class="headerlink" title="我想要做些什么呢"></a>我想要做些什么呢</h2><p>这里列下我想要做的事情，在 2025 年已经过玩 5% 的当下，2026 年初的时候，我再回看这里，我又能够做成了那些事情呢？顺序不区分先后，单纯罗列。</p><ul><li>想要学习绘画，先从像素画开始。</li><li>准备找工作，需要刷算法题，刷面试题，写简历，投简历，面试。</li><li>出海建站，独立开发。能够拥有额外收入，如果足够的多，我能否就不再需要工作呢？</li><li>学会投资，第一步从看书和创建帐号开始。但是绝对不碰 A 股和港股。</li><li>尝试健身。合理饮食，提高身体素质。</li><li>……还有之前的一些想法，我也许会找个单独的地方记录下这些想做的事情。</li></ul><p>写下之后，也许我真的可以开始尝试做这些事情了，时间很多，时间很少。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>让我们下周再见，看看我在一周的时间里做了些什么？</p>]]></content>
      
      
      <categories>
          
          <category> Weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广来这周在做什么 007</title>
      <link href="/what-is-guanglai-doing-this-week-007/"/>
      <url>/what-is-guanglai-doing-this-week-007/</url>
      
        <content type="html"><![CDATA[<p>这里是广来这周在做什么的第七期，这周也是感觉做了很多，但是什么也没做的一周。这周更加深入地使用和了解了 AI，基本上形成了自己使用 AI 的方式。买了一个便宜的 VPS，使用阿里云 OSS 搭建了一个个人图床。</p><span id="more"></span><h2 id="先看看猫"><a href="#先看看猫" class="headerlink" title="先看看猫"></a>先看看猫</h2><p>不过猫不是我的。</p><p><img data-src="https://aliyun-oss-guanglai-me.oss-ap-southeast-1.aliyuncs.com/picgo/naiyou-250112.jpg"></p><h2 id="还是-AI"><a href="#还是-AI" class="headerlink" title="还是 AI"></a>还是 AI</h2><p>我现在常用的 AI 服务如下</p><ul><li>Chat GPT</li><li>Deepseek</li><li>Google Gemini</li><li>Github Copilot</li></ul><p>Chat GPT 使用桌面客户端，Option + Space 快捷键唤起，简单问个问题比 Google 更加方便和快速。Chat GPT 现在基本模型是免费的，只是日常使用的话完全够用，没有必要升级到 plus 版本，并且大陆用户现在也不需要额外的方式，就可以直接使用。</p><p>Deepseek 的网页聊天页面功能虽然很简陋，但是日常使用还是没有什么问题的，作为 GPT 的替代场景是足够的。</p><p>Deepseek 的另外的主要使用场景是一些软件需要 LLM API 作为基座提供功能的场景。Deepseek 能够提供非常便宜的 API token，需要使用 API key 的场景，基本就借助 Deepseek。目前主要在用的是 Chrome 扩展，沉浸式翻译和 VS Code 扩展 Roo Cline。</p><p>沉浸式翻译基本上是现在在 Chrome 扩展中最好用的翻译扩展了，当然这只是我个人观点，没有数据佐证。默认沉浸式翻译是使用谷歌翻译，网易翻译之类的免费翻译，这部分能力也是内置在扩展里的。如果需要通过大模型翻译，有两种方式。一种是升级会员，另一种是使用用户个人提供的大模型 API token。一般来说，大部分的语言模型的 API 都是 Open AI 兼容的，所以基本也都可以使用。</p><p>Roo Cline 则是在 VS Code 编程中，使用起来非常方便的大语言模型编程扩展。不过受限于 Deepseek 的 API 时不时抽风的特点，有时候的请求非常快速，有时候的请求则非常慢，要在 API request 页面转圈几分钟到十几分钟，才能完成一次请求，实在是无法忍受。这里猜测的原因应该是 Deepseek 非常便宜，导致大量人群使用 Deepseek，导致 Deepseek 流量暴涨。尤其是在晚上的时候，请求尤其卡顿，根本无法用于辅助编程。Deepseek 官方虽然说不会限制 API 的请求速率，依我看来，是有点有心无力了。</p><p>既然 Deepseek 没有办法了，那么有没有替代品呢？有，Google Gemini 2.0 flash，谷歌的 gemini 2.0 目前是体验版本，2.0 系列的模型目前都是免费体验的，至于免费到什么时间？不知道，能用就先用着。有两个 API，<code>gemini-2.0-flash-exp</code>， <code>gemini-exp-1206</code> 是比较强的模型，推荐使用。但是直接使用是有点问题的，需要中转一下。Github 上就有人开源了一个<a href="https://github.com/PublicAffairs/openai-gemini">项目</a>，通过 cloudflare worker 中转一下 gemini 的 API。这里 cloudflare worker 做了两件事情。第一件是 gemini 不支持中国大陆使用。第二件是 gemini 的 API 接口不兼容 Open AI。不过，官方文档里，不止支持 cloudflare，只是对我来说 cloudflare 最为方便。cloudflare 当真是赛博菩萨，让我们谢谢 cloudflare。</p><p>有了 Gemini 的 API 之后，就可以和 Deepseek 一样，在 Roo cline 中使用了。并且 Roo cline 是支持多种配置的，同时配置两个，当 Deepseek 不可用的时候，就采用备用方案 Gemini。另一方面，Deepseek 因为上下文比起其他模型是在是太短了，尝试在 Cursor 中使用，基本是不可用的。Gemini 则是可以的。</p><p>最后就是我们的老朋友 Github Copilot 了。在 Jetbrains 系列的编程 IDE 上，基本上没有什么好用的，类似 Roo Cline 的接入第三方 API key 的大模型辅助编程插件。Jetbrains 系列的 IDE 是有这类插件的，但是我尝试了之后，发现至少在我的体验下是不可用的。那么只剩下一些官方提供的了。比如 Jetbrains AI assistant，Github Copilot 等等，Jetbrains AI assistant 国内是使用的文心一言的 API，Pass。那么可用的也只剩下 Github Copilot 了。不过能用的场景有限。Copilot 现在每月也有免费额度，作为兜底使用的 AI 编程插件，足够使用了。</p><p>以上，就是我目前正在使用的 AI 了。也算是跟上了 AI 的潮流了。</p><p>那么我用 AI 做了那些事情呢？两类事情 AI 是直接刷新了我的认知的。一类事情是问答类的事情，先前如果我们有什么不懂的，基本就是搜索引擎，或者特定网站搜索关键字，运气好的话，可以找到很好的解答。运气不好的话，一无所获。而且这类事情非常花费时间。那么现在呢，基本上我在碰到不懂的概念的时候，就会先去尝试问下 AI，大部分的时候都能够得到足够好的回复。并且在学习的时候，尤其好用。学习的能力在 AI 的帮助下现在是 up up 了。不过也要警惕 AI 提供的知识，并不是完全可信的。</p><p>第二件事情是编程类的事情。一方面，我现在碰到复杂点的程序，就会丢给 AI，让 AI 帮忙解释下这段程序的含义，有时是学习的时候，因为是自己不了解的领域，用 AI 辅助学习。有时是，因为我需要使用到这段代码，但是又不知道这段代码的含义，就让 AI 帮忙分析下，是否有恶意的成分在，避免被攻击。另一方面，我用编程开发了一款 Chrome 扩展，基本上是抱着学习的目的。在我学习完成的现代前端的大部分技术栈，只是简单了解的情况下，和 AI 描述需求，在自己的理解下，开发完成了一款 Chrome 扩展。确实有现今的一个段子的味道了。</p><blockquote><p>我不会编程，但是靠 cursor，编写了一个 iOS APP，并且上架了 APP Store</p></blockquote><p>当然了，我是会编程的，还是个老后端程序员了。如果不会编程，我大概连提问 AI 都不知道该提问些什么，即使是有 AI 的帮助，还是需要前置知识的辅助的。提这个也不是想要说明什么，只是觉得有点意思，最近确实很多人有点过于炒作 AI 编程和制造焦虑了。AI 确实大大降低了我的心智负担，但是目前还只是辅助的能力。当真的 AI 哪一天不再是 Copilot 了，而是能够掌舵了，那么大家就都可以下岗了，你我都不例外。所以没什么可以焦虑了，那个时候，我们都可以去捡瓶子，睡大街了。现在？现在拥抱 AI，让 AI 做好 Copilot 的工作就可以了，我们是下指令的。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>这周主要就是沉浸在 AI 给我的震撼上了，深度体验了 AI 的方方面面。不过还有一些有待我的探索。文生图，文生视频，AI 实时语音通过，视频识别，这些就留待以后探索吧。</p><p>这周还做了些什么事情呢？我购买了一个 VPS，价格非常便宜，7刀&#x2F;第一年，1 Core，1GiB，RAM 20 GiB Storage，还是比较划算的。之后如果我有什么想要部署的，会用下这个 VPS。我也许不用，但是还是需要一个 VPS 的。购买之后，也写了一个购买服务器之后的 SOP，有机会会整理一下分享出来，不过主要是参考别人的文章，做了一点自己的小小的修改。</p><p>这周也看了很多的博客，没看什么书，没学什么习。我发现还是有很多人在维护和编写个人博客的。现在大家都被困在各类 APP 的信息茧房里，还有很多人坚持写博客，也是独树一帜了。博客不会被大平台管控，我个人也是很喜欢的，只是是需要一点门槛的。所以即使在各类博客平台上写些什么的人，也是很厉害的。只要在写些什么，那就是有输出的。输出重要的不是什么形式，什么平台，我们需要去创造写什么，浪费才华，才不会空有品位。</p><p>这周也搭建了个人图床，以后就不再使用本地图片了。编写文章，转换各种格式到不同平台就更加方便了。我现在写完博客之后，还会存档一份内容到微信公众号。之前图片都是在转换之后，手动上传到微信公众号的，现在就不太需要了。写完博客之后，转换到其他平台的格式 easy easy。个人图床的搭建的话，主要还是阿里云 OSS，加上本地的客户端 PicGo。阿里云我使用的是新加坡的标准本地冗余，每月 40G，一年的费用只需要 9 元，等于白送了。</p><p>下周的话，还是多学习学习，我要准备找工作啦。两手抓，一手学习找工作，一手学习做网站。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，如果真的有人能看到这里的话，感谢你的耐心。我的微信公众号目前是没有流量和关注的，而且博客并没有被 Google 搜录，所以我估计真的有人访问的话，也要很久之后了。即使没什么看，我也还是要继续写哒，未来的我，也是读者之一。我们下周见。</p>]]></content>
      
      
      <categories>
          
          <category> Weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> AI </tag>
            
            <tag> Deepseek </tag>
            
            <tag> Gemini </tag>
            
            <tag> Github Copilot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广来这周在做什么 006</title>
      <link href="/what-is-guanglai-doing-this-week-006/"/>
      <url>/what-is-guanglai-doing-this-week-006/</url>
      
        <content type="html"><![CDATA[<p>这周基本没有再继续学习前端了，尝试用学到的技术栈做一个实际的项目，最后想到一个之前想做的 Chrome 扩展，就是动手实现了这个扩展，并且成功上架到了 Chrome 商店。</p><span id="more"></span><h2 id="跨年夜的烟花"><a href="#跨年夜的烟花" class="headerlink" title="跨年夜的烟花"></a>跨年夜的烟花</h2><style>.mibihlscablw{zoom:10%}</style><style>.oyjivtefagfj{zoom:10%}</style><style>.wpwhpiuoecnv{zoom:10%}</style><p>过去的一周刚好包含了元旦，跨过了 2024 年，现在是 2025 年了，所以这篇是 2025 年的第一篇 🎇。上面是上海吴淞口的元旦跨年烟花。当天是之前在网络上聊过的一个女生，简化版本的邀约就是，她询问我要不要一起去吴淞口看烟花。31 号晚上我本身也没有什么安排，也就欣然赴约。不得不说，跨年夜出门的人是相当的多，如果真的准备跨年的话，还是要提早出发的。我是六点多出发的，已经没办法去到观看烟花的最佳位置了。最后就是在一个狭小的角落看完了无人机和烟花秀。当天和女生聊了很多爱好，习惯，看法之类的话题，我觉得聊得是非常开心的。我们当天是聊到了凌晨三点半才各自打车回家。毕竟如果真的聊得一般的话，我觉得双方都不会在大冬天的大半夜外面聊到凌晨三点多吧。所以我原本以为是遇到了合适的，同频的朋友，回来之后的聊天就给了我当头一棒。女生回复我的消息是相当之慢的，大概十几分钟到十几小时会回复下我的消息吧。以至于给我的感觉是把即时通讯软件，使用成了邮箱这样的电子书信方式的聊天工具。</p><h2 id="Chrome-扩展"><a href="#Chrome-扩展" class="headerlink" title="Chrome 扩展"></a>Chrome 扩展</h2><p>这周刚开始，就有了做一个 Chrome 扩展的想法，索性也是做好了。插件最终上架到了 Chrome 商店，给了我非常大的成就感。Chrome 商店的开发者帐号，只需要一次支付 5 刀就可以一直上传扩展。扩展的名称是 Url Tools，当前的主要功能就是在扩展弹窗里，解析输入的 url 参数，并且允许编辑解析后的 url 参数，最后获取编辑后的 url 参数。我的后续计划是会继续往扩展里增加新的功能。TODO 项增加量了。这里是<a href="https://chromewebstore.google.com/detail/url-tools/hhcimehhgoefjjonjmmjglibjmdbdfph">扩展在 Chrome 商店的地址</a>。</p><p>插件整体是使用现在前端技术构建的，具体使用了 React，TypeScript，TailwindCSS，Vite，Shadcn UI。技术选型上都是我做的技术选型，也是以后我做独立开发，独立网站的技术选型，借助了 Github Copilot 辅助编程。当然做网站的话，需要加上 Next.js 就完整了，但是浏览器扩展就实在是不需要 Next.js 的那些功能了。</p><h2 id="AI-编程"><a href="#AI-编程" class="headerlink" title="AI 编程"></a>AI 编程</h2><p>上面的 Chrome 扩展就是我在 Github Copilot 的帮助下辅助编程的，也正如 Copilot 的名称展示的，Copilot 给我的感觉是非常有限。这两天我又接触到了 Deepseek，加上 VS Code 的插件，Roo Cline，在 VS Code 上的体验，我个人觉得是比 Copilot 优秀的。不够也不用局限于单一产品，这两者在 VS Code 上同时使用也并不冲突。继续体验使用 AI 辅助编程就好了。</p><h2 id="AI-工具"><a href="#AI-工具" class="headerlink" title="AI 工具"></a>AI 工具</h2><p>既然上面提到的 AI 编程，AI 最大的用途还是在各种生活场景里使用，什么不懂了，不知道了，就都可以尝试问问 AI。我现在正常在使用的 AI 模型，除了 Copilot，还有 ChatGPT，和 Deepseek。ChatGPT 本身就提供了足够可用的免费的模型，Deepseek 则更多是在提供 API token 方面。目前 AI 大模型整体的开放 API 都是兼容 OpenAI 的，所以只需要一个 API token，同一个工具就可以在各家大模型之间切换了。</p><p>Deepseek 目前正好在优惠体验期，价格上也算便宜，我把主力在用的工具都使用上了 Deepseek 的 API token。</p><ul><li>immersivetranslate，Chrome 的扩展，沉浸式翻译。在网页中翻译大量的英文文本非常舒服，本身自带的免费翻译功能是有 Bing 和 Google 提供的。如果要使用其他能力，需要付费升级为 Pro 版本，或者使用大模型厂商提供的 API token。我就尝试使用了 Deepseek 替换了默认的 Google 翻译。</li><li>VS Code。上文也有提到，VS Code 中，使用 Roo Cline（Cline 的 fork），编码方面的体验也是非常优秀的。</li><li>ChatBox 如果需要有着面级别的聊天对话框，我尝试了 ChatBox，目前还没有怎么体验，如果后续有的话，再更新体验。</li></ul><h2 id="羽毛球"><a href="#羽毛球" class="headerlink" title="羽毛球"></a>羽毛球</h2><p>最近羽毛球打的次数非常少了，今天也是上完了最后一次的羽毛球教练课。这两天的天气倒是比上周暖和了一些，没有之前那么得冷了。上周看到的把羽毛球场换成了篮球场的地方，这周又换回了羽毛球的场地，我猜测是因为篮球太超了，还没有和羽毛球场地之间有隔断:)</p><h2 id="赚钱"><a href="#赚钱" class="headerlink" title="赚钱"></a>赚钱</h2><p>最近有想过投资和做独立网站赚钱，还在努力学习中。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是这周我主要在做的事情了，下周见。</p>]]></content>
      
      
      <categories>
          
          <category> Weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广来这周在做什么 005</title>
      <link href="/what-is-guanglai-doing-this-week-005/"/>
      <url>/what-is-guanglai-doing-this-week-005/</url>
      
        <content type="html"><![CDATA[<p>这周总算是把前端相关的基础看完了，快速地扫了一遍 HTML，CSS，JavaScript，TypeScript，Shadcn UI 相关的内容，接下来的安排就是准备做一些实际的项目。</p><span id="more"></span><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>最近一个多月都在唠叨前端相关的事情，真要认真学，就是以我现在上工作的时间，下班闲暇时间，一周的时间也绰绰有余了，毕竟也是工作了四年的多后端，虽然对前端技术不甚了解，对计算机系统的了解也是了然于心了，只是需要对前端相关的知识补充下认知。</p><p>具体来说，这段时间我究竟做了什么呢？一开始就是看到了 Next.js 的两个教程。</p><ul><li><a href="https://nextjs.org/learn/react-foundations">React Foundations | Next.js</a></li><li><a href="https://nextjs.org/learn/dashboard-app">Learn Next.js | Next.js</a></li></ul><p>跟着教程，一知半解地学完了 React 和 Next.js，这个时间点，我的前端知识库还是很久之前的，对 HTML，CSS，JavaScript 也是一知半解。也是多亏了 Next.js 的教程，我对前端工程有了基本的认知。因为对基础的三大基本组件（HTML…）不过，所以回炉重造，重新学了 HTML，CSS，JavaScript。</p><p>之后顺便也弄懂了一些其他的前端组件。包含单不只是 TypeScript，Vite，TailwindCSS，Shadcn UI。</p><p>MDN 也对前端工具链有一个扫盲方式的介绍，足够详细。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Client-side_tools">Understanding client-side web development tools - Learn web development | MDN</a></li></ul><p>就我个人的粗浅理解，以下是现代前端开发的主要工具链。</p><ul><li>基础 HTML，CSS，JavaScript。</li><li>包管理器 npm，现代前端依赖管理的基石。</li><li>node 是 JavaScript 在浏览器之外的运行时，主要服务于服务端相关技术。当然依赖管理等一系列的工作也依赖 node，并且还有其他类似 node 的运行时，比如 deno 和 bun，有很多可以写的，不细写了。</li><li>UI 框架，React &#x2F; Vue 等。使用原生 HCJ 构建前端需要手动操作 DOM，UI 框架提供了更方便的组件工具用于构建 UI。</li><li>PostCSS。原生 CSS 的功能有限，PostCSS 扩展了 CSS 的能力。</li><li>组件库。CSS 基础之上，为了减少编写，管理，维护 CSS 的困难，出现的 TailwindCSS 之类处理 CSS 的组件库。</li><li>UI 组件库。基于 CSS 组件库之上，一套可复用的 UI 组件库。</li><li>构建工具。Vite 构建和减少代码提及，自动编写配置。</li></ul><p>其他还有编辑器相关的，格式化，和代码检测工具。可见现代前端工程十分庞杂，强大。</p><h2 id="cheatsheet"><a href="#cheatsheet" class="headerlink" title="cheatsheet"></a>cheatsheet</h2><p>在了解完基础概念之后，作为快速过一遍的文档，<a href="https://cheatsheets.zip/">CheatSheets.zip - Ultimate Cheat for Developers</a> 是挺不错的，就像是记录好重点的学习笔记一样。</p><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p>这周经常性尝试使用 Github Copilot 辅助编程，我的体验还是比较舒服的。</p><p>在大代码库的代码编写上，Github Copilot 爱莫能助，设计逻辑性相关的功能实现，如果比较复杂的部分，我会声明式地方式描述给 Copilot，让它帮忙编写函数，然后我再实际验证功能是否满足，这方面的体验良好。</p><p>另一方面，我发现 Github Copilot Chat 用来学习编程非常棒。我一有不了解的技术概念就会直接提问给 Copilot，Copilot 的回复我看完之后基本就能了解这项技术概念了。辅助编程学习的体验非常良好。</p><p>一个例子：</p><blockquote><p>Q: JavaScript this 关键字<br>在 JavaScript 中，<code>this</code> 关键字是一个非常重要的概念，它指向当前执行上下文的对象。<code>this</code> 的值在不同的上下文中会有所不同，因此理解它的工作原理对于编写正确的 JavaScript 代码至关重要。</p><h3 id="1-全局上下文"><a href="#1-全局上下文" class="headerlink" title="1. 全局上下文"></a>1. 全局上下文</h3><p>在全局上下文中（即代码在函数外部运行时），<code>this</code> 指向全局对象。在浏览器中，全局对象是 <code>window</code>，在 Node.js 中，全局对象是 <code>global</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 在浏览器中输出: Window</span></span><br></pre></td></tr></table></figure><h3 id="2-函数上下文"><a href="#2-函数上下文" class="headerlink" title="2. 函数上下文"></a>2. 函数上下文</h3><p>在函数内部，<code>this</code> 的值取决于函数的调用方式。</p><h4 id="a-作为普通函数调用"><a href="#a-作为普通函数调用" class="headerlink" title="a. 作为普通函数调用"></a>a. 作为普通函数调用</h4><p>当函数作为普通函数调用时，<code>this</code> 指向全局对象（在严格模式下，<code>this</code> 是 <code>undefined</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showThis</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showThis</span>(); <span class="comment">// 在非严格模式下输出: Window (浏览器中)</span></span><br></pre></td></tr></table></figure><h4 id="b-作为对象的方法调用"><a href="#b-作为对象的方法调用" class="headerlink" title="b. 作为对象的方法调用"></a>b. 作为对象的方法调用</h4><p>当函数作为对象的方法调用时，<code>this</code> 指向调用该方法的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// 输出: Alice</span></span><br></pre></td></tr></table></figure><h4 id="c-构造函数调用"><a href="#c-构造函数调用" class="headerlink" title="c. 构造函数调用"></a>c. 构造函数调用</h4><p>当函数作为构造函数调用时（使用 <code>new</code> 关键字），<code>this</code> 指向新创建的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// 输出: Bob</span></span><br></pre></td></tr></table></figure><h3 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3. 箭头函数"></a>3. 箭头函数</h3><p>箭头函数没有自己的 <code>this</code> 值，它会捕获其所在上下文的 <code>this</code> 值，即箭头函数中的 <code>this</code> 是在它定义时决定的，而不是在调用时决定的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">arrowFunction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">arrowFunction</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">greet</span>(); <span class="comment">// 输出: Charlie</span></span><br></pre></td></tr></table></figure><h3 id="4-显式绑定"><a href="#4-显式绑定" class="headerlink" title="4. 显式绑定"></a>4. 显式绑定</h3><p>可以使用 <code>call</code>、<code>apply</code> 和 <code>bind</code> 方法显式地绑定 <code>this</code>。</p><h4 id="a-call-方法"><a href="#a-call-方法" class="headerlink" title="a. call 方法"></a>a. <code>call</code> 方法</h4><p><code>call</code> 方法调用一个函数，并显式指定 <code>this</code> 的值和参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Dave&#x27;</span> &#125;;</span><br><span class="line">greet.<span class="title function_">call</span>(user); <span class="comment">// 输出: Dave</span></span><br></pre></td></tr></table></figure><h4 id="b-apply-方法"><a href="#b-apply-方法" class="headerlink" title="b. apply 方法"></a>b. <code>apply</code> 方法</h4><p><code>apply</code> 方法类似于 <code>call</code>，但它接受一个参数数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Eve&#x27;</span> &#125;;</span><br><span class="line">greet.<span class="title function_">apply</span>(user, [<span class="string">&#x27;Hello&#x27;</span>]); <span class="comment">// 输出: Hello, Eve</span></span><br></pre></td></tr></table></figure><h4 id="c-bind-方法"><a href="#c-bind-方法" class="headerlink" title="c. bind 方法"></a>c. <code>bind</code> 方法</h4><p><code>bind</code> 方法创建一个新的函数，并将 <code>this</code> 绑定到指定的对象，新的函数可以在以后调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Frank&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> boundGreet = greet.<span class="title function_">bind</span>(user);</span><br><span class="line"><span class="title function_">boundGreet</span>(); <span class="comment">// 输出: Frank</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>全局上下文</strong>：<code>this</code> 指向全局对象（浏览器中是 <code>window</code>，Node.js 中是 <code>global</code>）。</li><li><strong>函数上下文</strong>：<code>this</code> 的值取决于函数的调用方式（普通函数、对象方法、构造函数）。</li><li><strong>箭头函数</strong>：<code>this</code> 绑定在定义时的上下文。</li><li><strong>显式绑定</strong>：使用 <code>call</code>、<code>apply</code> 和 <code>bind</code> 方法可以显式绑定 <code>this</code>。</li></ul><p>理解 <code>this</code> 的行为对于编写和调试 JavaScript 代码至关重要。通过掌握这些规则，你可以更准确地控制函数的执行上下文。</p></blockquote><p>基础的点都有提到，很棒了。</p><p>模型方面，Github Copilot 现在提供的基础版本是 GPT-4o，作为预览的功能，可以切换到 o1-mini，o1，或者 Claude 3.5 Sonnet。但是在辅助学习方面还是 GPT-4o 最快也最方便。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最近有打算写一个简单的浏览器插件，也是我自己想要用的浏览器插件，本身功能还是比较简单的，基于 AI 辅助，一边学习一边写，完成一个工程会比较有成就感就是。</p><p>Roadmap.sh 中的前端部分也还是要继续跟的，往全栈发展。如果有时间，真的，写一个博客网站？但是部署是个很大的问题。</p><p>涉及到代码部署的部分，前端相关 Vercel 的免费版本基本满足需求，如果我构建的网站流量能够达到免费流量之外，那么 20 美元一个月的付费版本我觉得也可以接受，这个阶段，我也应该在网站上有收入了。也是我的最终目的。</p><p>路漫漫，一步步走。考虑未来，享受当下。下周见。</p>]]></content>
      
      
      <categories>
          
          <category> Weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广来这周在做什么 004</title>
      <link href="/what-is-guanglai-doing-this-week-004/"/>
      <url>/what-is-guanglai-doing-this-week-004/</url>
      
        <content type="html"><![CDATA[<p>这里是广来这周在做什么的第四期，这周做的事情很杂乱，该做的事情却基本没有怎么做。</p><p>花了不少时间了解了像素画，然后就更想了解颜色理论，但是没有很理解现有的色彩理论。更多尝试了 ai copilot code 的能力。继续在学习前端。和网友去了西岸梦工厂，也算是过了圣诞。时隔一个月，又去上了一次羽毛球课。</p><p>我的文字表达的能力我觉得还是不太行，所以我还是要继续多写，文字是和未来时空交流的一种媒介，不写下来就消失在时间的河流里了。</p><span id="more"></span><h2 id="像素画"><a href="#像素画" class="headerlink" title="像素画"></a>像素画</h2><p>读了 <a href="https://blog.douchi.space/100-days-of-pixel-art/#gsc.tab=0">像素画的一小步，我人生的一大步 —— 100 days of pixel art | 椒盐豆豉</a> 这篇博文，对像素画起了一点兴趣。博文里提到了门槛低，对于我这个多次尝试学习一门艺术的人来说，也是非常有吸引力的。</p><blockquote><p>无论从绘画技巧、审美天赋、硬件要求和教程资源而言，像素画都算是各种视觉艺术形式里对外行和新手最友好的了。我，一个学了两次素描都半途而废，毫无绘画基础 perspective 差得要死，procreate 买了没用超过三次的中年人，找这种 less intimadating 的技巧下手心理障碍小了很多。</p></blockquote><p>那么我这周为了学习像素画做了哪些努力呢？我去 Reddit 的 PixelArt 社区逛了逛，读了入门教程。看了推荐的入门书籍 <code>Make Your Own Pixel Art</code>，不过只看到了阴影部分，看来无论学习什么绘画艺术，该有的空间，颜色理论学习也都是少不了的。尝试跟着书籍里的教程，画了第一张像素画。</p><p>不过最近还是会暂停学习像素话，专注主线任务。</p><h2 id="色彩理论"><a href="#色彩理论" class="headerlink" title="色彩理论"></a>色彩理论</h2><p>一部分的原因是在 <code>CSS</code> 学到的颜色相关的部分，一部分是我在学习像素画的时候，也碰到了不知道如果选择合适的颜色的问题。我很好奇网站的设计师究竟是如何选择颜色的？我应该怎么学习选择合适的颜色？另我学习到的颜色混合又究竟是什么，RGB 是什么？RYB 是什么？CMYK 是什么？我过往就有了解过色彩理论，但是一直都是一知半解，疑惑非常多。我去视频网站看了博主的科普介绍，在 Wiki 百科也看了色彩理论的详细描述。现在也还是非常模糊。</p><p>即使我问了 AI 色彩理论是什么？AI 给了我回复，和视频网站的科普，Wiki 百科的介绍都有重合，我能理解色彩理论的应用。但是我仍然没能理解背后的道理。如果我哪一天明白了，我再写一边博文描述下我理解的色彩理论。</p><p>以下是 Github Copilot 给出的色彩理论的简要解释。</p><blockquote><p>现代色彩理论（也称为色彩科学）是关于颜色的生成和感知的科学原理和应用的研究。它结合了物理学、生物学、心理学和艺术学等多个学科。以下是一些现代色彩理论的关键概念：</p><ol><li><p><strong>色彩模型</strong>：</p><ul><li><strong>RGB模型</strong>：基于红色 (Red)、绿色 (Green) 和蓝色 (Blue) 三种颜色的加色模型。广泛应用于电子显示器、电视、计算机屏幕等。</li><li><strong>CMYK模型</strong>：基于青色 (Cyan)、品红色 (Magenta)、黄色 (Yellow) 和黑色 (Key) 的减色模型。主要用于彩色打印。</li><li><strong>HSV&#x2F;HSB模型</strong>：基于色调 (Hue)、饱和度 (Saturation) 和明度 (Value&#x2F;Brightness) 的模型。常用于图形设计和图像处理。</li></ul></li><li><p><strong>色轮</strong>：</p><ul><li>色轮是色彩关系的可视化工具，展示了颜色的连续性和相互关系。通常包括原色、间色和复色。</li></ul></li><li><p><strong>色彩和光</strong>：</p><ul><li>色彩是由光的不同波长引起的。人眼能感知到的光谱范围大约在380纳米到740纳米之间。</li><li>颜色感知是由视网膜中的锥细胞负责的，这些锥细胞分为三类，分别对红、绿、蓝三种光敏感。</li></ul></li><li><p><strong>色彩心理学</strong>：</p><ul><li>色彩能够影响人们的情绪和行为。例如，红色通常与热情和紧张联系在一起，而蓝色则常与平静和冷静相关。</li></ul></li><li><p><strong>色彩和文化</strong>：</p><ul><li>不同文化对颜色有不同的象征意义。例如，在西方文化中，白色通常象征纯洁，而在一些东方文化中，白色可能与哀悼相关。</li></ul></li><li><p><strong>色彩和艺术</strong>：</p><ul><li>在艺术中，色彩用于表达情感、构建氛围和传达信息。艺术家使用色彩理论来选择和组合颜色，创造和谐或对比的视觉效果。</li></ul></li><li><p><strong>色彩的应用</strong>：</p><ul><li>色彩理论在设计、广告、时尚、室内装饰等领域有广泛应用。设计师使用色彩理论来提高视觉吸引力和传达特定信息。</li></ul></li></ol><p>理解和应用现代色彩理论可以帮助人们更好地运用色彩，创造出令人愉悦且有效的视觉体验。 </p></blockquote><h2 id="AI-Code-Copilot"><a href="#AI-Code-Copilot" class="headerlink" title="AI Code Copilot"></a>AI Code Copilot</h2><p>这周比较大的消息是 Github Copilot 释出了免费计划，在不付费的情况下也可以在部分限制的情况下使用 Github Copilot。尝试使用 Github Copilot 免费版本编写真实的解决现实的问题的代码，AI 在这方面确实比我好了太多。在我对 Python 和 Pandas 熟悉程度有限的情况话，编写了基本不需要怎么改动就可以直接使用的代码，接下来我应该会重度尝试使用 Copilot 辅助编程。</p><h2 id="西岸梦工厂"><a href="#西岸梦工厂" class="headerlink" title="西岸梦工厂"></a>西岸梦工厂</h2><p>这周和认识的网友，相约见面，对面选择了西岸梦工厂这个地方，似乎是今年刚建成的新的露天商场。沿着黄浦江西岸建成，散步的时候非常有感觉，只是冬天实在是有些冷了，如果是夏天再这边散步相比会好很多。顺带，也算是过了圣诞，感谢网友，我原本以为我几年仍然没有什么机会过圣诞的呢。</p><p>po 两张西岸梦工厂的圣诞节巨鹿，网友拍的比我有质感多了。我的使用手机拍摄 iPhone 15 Pro，网友是使用相机拍摄，型号未知，定焦镜头。</p><style>.zabsskvmkhbp{zoom:18%}</style><style>.ibyweopgeyem{zoom:10%}</style><h2 id="羽毛球"><a href="#羽毛球" class="headerlink" title="羽毛球"></a>羽毛球</h2><p>时隔一月再去上羽毛球课，还是在大冬天，实在是要了我这个最近运动很少的人的老命。真实描述的感觉就像是在大冬天在户外跑了一千米，冷空气迸肺的感觉实在是不好受。球场估计也是因为去打羽毛球的人少了，居然将两块羽毛球的场地换成了篮球的场地。整块球场也大部分都是在上羽毛球课的，主力军是小孩们，大人们则更多是在边上玩着手机，陪着小孩上课。熟人之间打球在冬天的休息日少了不少。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后的事情，其实应该是我最近的主线任务，学习前端。不过一直都在做支线，这里搞搞，那里搞搞，主线却一直都没有推进。支线我倒是没有觉得很浪费时间，但是我一直有在刷社交媒体，视频网站，倒是真的很浪费时间。我需要专注一点啊。</p><p>一直在看 MDN 的入门教程，CSS 部分看得我昏昏欲睡，十分枯燥，去 Reddit 逛了一逛，知道了还是有谷歌的 web.dev，看了 HTML 的入门教程，还算不错，就先大致浏览一下 web.dev 的入门教程吧，要快点动手写点什么了。</p><p>这周在做的事情大致就是这些，下周再见。</p>]]></content>
      
      
      <categories>
          
          <category> Weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 MacOS 上编译 Aseprite，Step By Step</title>
      <link href="/how-to-compile-aseprite-on-macos/"/>
      <url>/how-to-compile-aseprite-on-macos/</url>
      
        <content type="html"><![CDATA[<p>Aseprite 是一款像素画绘制工具软件，我有打算学习像素画，尝试在 MacOS 上编译 Aseprite，于是记录下编译过程中碰到的问题。我编译的版本是 <code>Aseprite v1.3.10.1</code>，对应的 skia 预编译文件是 <code>Skia-m102</code>。</p><p><strong>Aseprite 在 Steam 是有在售卖的，中国区的价格是 70 元，后面打折的时候，可以支持下作者。</strong></p><p>Github 上有源码可以下载自行编译，正常编译只需要几分钟就可以编译完成。</p><span id="more"></span><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>官方文档是有指导如何在 Windows, Mac OS，Linux 三个主流操作系统上编译 Aseprite 的指导文档的，按照官方文档编译基本不会出什么问题。</p><ul><li><a href="https://github.com/aseprite/aseprite/blob/main/INSTALL.md">aseprite&#x2F;INSTALL.md at main · aseprite&#x2F;aseprite</a> 安装文档，按照该文档编译即可</li><li><a href="https://github.com/aseprite/skia">aseprite&#x2F;skia: Skia is a complete 2D graphic library for drawing Text, Geometries, and Images.</a> Aseprite 的默认依赖，编译前需要先编译或者下载预编译的 skia 库</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>获取源码。可以直接从 <a href="https://github.com/aseprite/aseprite/releases">Releases · aseprite&#x2F;aseprite</a> 页面下载当前稳定版本的源码。</p><p>skia 依赖库。同样可以从 <a href="https://github.com/aseprite/skia/releases">Releases · aseprite&#x2F;skia</a> 页面下载预编译的 skia 文件。把编译好的 skia 放在 <code>$HOME/deps/skia</code> 目录下，编译过程时需要指定 skia 依赖的路径。</p><p>构建工具。可以使用 Homebrew 安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake ninja</span><br></pre></td></tr></table></figure><p>macOS 系统依赖</p><blockquote><p>On macOS you will need macOS 11.3 SDK and Xcode 13.1 (older versions might work).</p></blockquote><p>下载 Xcode 即可。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>先在项目根目录创建构建目录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><p>Apple Silicon 用户可以用下面的命令构建编译参数。其他平台或架构可以按照官方文档修改。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cmake \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=RelWithDebInfo \</span><br><span class="line">  -DCMAKE_OSX_ARCHITECTURES=arm64 \</span><br><span class="line">  -DCMAKE_OSX_DEPLOYMENT_TARGET=11.0 \</span><br><span class="line">  -DCMAKE_OSX_SYSROOT=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \</span><br><span class="line">  -DLAF_BACKEND=skia \</span><br><span class="line">  -DSKIA_DIR=<span class="variable">$HOME</span>/deps/skia \</span><br><span class="line">  -DSKIA_LIBRARY_DIR=<span class="variable">$HOME</span>/deps/skia/out/Release-arm64 \</span><br><span class="line">  -DSKIA_LIBRARY=<span class="variable">$HOME</span>/deps/skia/out/Release-arm64/libskia.a \</span><br><span class="line">  -DPNG_ARM_NEON:STRING=on \</span><br><span class="line">  -G Ninja \</span><br><span class="line">  ..</span><br></pre></td></tr></table></figure><p>这里的 <code>-DSKIA_DIR=$HOME/deps/skia</code> 就是刚才下载的 skia 依赖库的路径。</p><p>使用下面的命令编译即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja aseprite</span><br></pre></td></tr></table></figure><p>编译好的二进制文件就在 <code>/build/bin</code> 目录下， 即 <code>aseprite</code>。到这边位置就算是编译完成了。</p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>编译完成的 <code>aseprite</code> 打开较为繁琐，并且没有 icon。需要优化下打卡方式。</p><ol><li>官网下载试用版本的 <code>aseprite</code>。</li><li>安装试用版本的 <code>aseprite</code>。</li><li>进入 <code>Applications</code> 目录，找到 <code>Aseprite</code>，鼠标右键点击 <code>Show Package Contents</code>，把编译好的 <code>aseprite</code> 和 <code>gen</code> 复制到 <code>Mac OS</code> 文件夹下即可。</li></ol><h2 id="中文汉化？"><a href="#中文汉化？" class="headerlink" title="中文汉化？"></a>中文汉化？</h2><p>我没有做~，先学起来吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.lxchapu.com/posts/compile-aseprite-on-mac/">在 Mac 系统手动编译 Aseprite - 柃夏chapu</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Piexl Art </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广来这周在做什么 003</title>
      <link href="/what-is-guanglai-doing-this-week-003/"/>
      <url>/what-is-guanglai-doing-this-week-003/</url>
      
        <content type="html"><![CDATA[<p>这里是广来这周在做什么的第三期，这周和朋友去苏州随心旅游去了，所有没有什么可写的，不过还是尽可能的记录一下。</p><p>这周前四天跟着 MDN 的 HTML 教程，学习了 HTML Table 和 Form 表单 HTML 部分的内容，目前的主要精力在 CSS 上。</p><p>毕竟也打算开始换份工作了，所以系统刷算法题，学习工程项目，系统设计，面试题也都要开始准备起来了。想要做的事情很多，不能继续荒废时间了。</p><span id="more"></span><h2 id="苏州"><a href="#苏州" class="headerlink" title="苏州"></a>苏州</h2><p>周五到周日三天时间和朋友去了苏州，实际上的是时间是周五的十一点左右从上海出发，周日的两点左右会到上海的出租屋。本着是躺平的想法，我们两个人没有做太多的规划。大致的计划是在苏州站回合，住宿在苏州博物馆附近，周围有很多可以去的地方。虽然是住宿在苏博附近，最终却并没有去苏博。没去苏博的原因倒是令人捧腹。我和朋友周四晚上打算预约苏博，开始是朋友截图给我他预订了苏博一点钟的门票，我也就同他一样，预约一点门票，计划是周五当天下高铁之后，先去吃饭，然后就去苏博逛逛。高铁站回合之后，却发现我朋友压根没有预订成功苏博管的门票。他只是填写的自己的个人信息，并没有点击最后一步的提交按钮。也就是，他以为他预订苏博的门票，然而实际上并没有。毕竟是本着躺平，随心旅游，于是我们也就放弃了这个计划，先打车去了酒店，放下东西，去周围逛逛吃吃。</p><h3 id="苏州的小吃"><a href="#苏州的小吃" class="headerlink" title="苏州的小吃"></a>苏州的小吃</h3><p>打车到住宿的地方，一眼就能看到『松鼠桂鱼』一类的苏州菜馆，在大众点评上搜索一下，也能看到非常非常非常多的写着松鼠桂鱼的苏州菜馆。苏州的松鼠桂鱼是真的多啊。我和朋友本身也是江苏籍贯，从小在江苏长大的，只是所处市县不是苏州，整体饮食风格是差不多的。躺平旅游的这几天，吃的最多的就是『汤包』，『生煎』，『汤面』之类的食物。当然晚上的娱乐，也会买点薯条，可乐，享受快乐人生。这一趟倒是没有吃到太多的苏州特色小吃。</p><p>周六的晚上，秉着<del>来都来了</del>，还是去了吃了酒店附近的松鼠桂鱼苏州菜馆。一百多的价格，两个人吃得很满足。</p><p>周日中午快离开的时候，去小吃点买了芋泥肉松团子，非常好吃，很推荐。</p><h3 id="逛了哪些地方"><a href="#逛了哪些地方" class="headerlink" title="逛了哪些地方"></a>逛了哪些地方</h3><p>没去成苏博，转头下午就去了狮子林方向的拙政园，来苏州当然是逛园林了。一个半小时到两个小时足够把拙政园大概逛一圈了。不过我们两个人实在也是没有太多文化底蕴，对园林背后的文化背景是一窍不通的。不同园林之间的区别是看不出来的，园林门匾上的字也是一半认识一半不认识的。没文化的我们只能看园林是园林。园林一类的经典，这趟就只逛了拙政园。</p><p>东方之门、盘门、东园和逛公园一样，散步逛了一圈，这趟是有够躺平的。活动范围就在酒店附近了。</p><style>.jfvxjbfqhwqe{zoom:10%}</style><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端还是前端三件套，努力学习 CSS 中。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>之前有看过一个 <a href="https://mtfront.notion.site/mtfront-shopping-reviews-e568ee6ebaa44b5da146cbe4ac4663eb">剁手安利数据库(mtfront-shopping-reviews)</a>，不过一直没看看这个页面的关于部分，周六的晚上，回到酒店之后，刷着电脑，逛了一逛。这位博主的博客是在是很有意思，有空还会在继续看看。</p><h3 id="一些有意思的博客"><a href="#一些有意思的博客" class="headerlink" title="一些有意思的博客"></a>一些有意思的博客</h3><ul><li><a href="https://blog.douchi.space/docs/about/#gsc.tab=0">About | 椒盐豆豉</a></li><li><a href="https://yayu.net/about">关于我 · 雅余 · 茶余饭后，闲情雅致</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这周是躺平的一周，积累了不少想做的事情，接下来准备好忙碌了。</p>]]></content>
      
      
      <categories>
          
          <category> Weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广来这周在做什么 002</title>
      <link href="/what-is-guanglai-doing-this-week-002/"/>
      <url>/what-is-guanglai-doing-this-week-002/</url>
      
        <content type="html"><![CDATA[<p>这是广来这周在做什么的第二期，这周主要在做的事情就是在学习前端和后端的之前不清楚的一些部分，有一些计划和打算构建的玩具项目。</p><p>这周基本看完了 <code>Next.js</code> 的基本用法，不过详细的官方文档还没有去看。弄懂了前端的各类组件库的作用，也发现了不少可用用于项目构建的 UI 组件库。</p><p>后端方面，对用户认证和授权有了一个初步的印象，大致浏览了一下 Java 9 ~ java 21 新出的特性。</p><span id="more"></span><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p><code>Next.js</code> 是我接下来一段时间主要准备学习的前端框架。学习 <code>Next.js</code> 的前提是 <code>HTML</code>，<code>CSS</code>，<code>JavaScript</code>，<code>React</code>，<code>TypeScript</code>。但是这些内容实际上我都是有些一知半解的，所以打算是回炉重造了。接下来有时间会吧 <code>MDN</code> 相关的基础部分详细浏览学习一遍，再看下 <code>TypeScript</code> 的基础语法。基本上就是下面这个路线先走一边。</p><ul><li>HTML &amp; CSS &amp; JavaScript</li><li>TypeScript</li><li>React</li><li>Next.js</li></ul><p>我做事情总是东一榔头西一棒，对很多不懂的事情都充满了好奇。之前一直不懂 <code>TailwindCSS</code> 是什么，UI 组件库是什么，这周也总算是弄懂了。</p><h3 id="TailwindCSS"><a href="#TailwindCSS" class="headerlink" title="TailwindCSS"></a>TailwindCSS</h3><blockquote><p>A utility-first CSS framework packed with classes like <code>flex</code>, <code>pt-4</code>, <code>text-center</code> and <code>rotate-90</code> that can be composed to build any design, directly in your markup.</p></blockquote><p>简单来说，TailwindCSS 工具化为先的 CSS 框架。关键词提取。</p><ol><li>工具化为先</li><li>CSS 框架</li></ol><p>知道了 TailwindCSS 是 CSS 框架之后，就可以了解下下面这些项目了。</p><ul><li><a href="https://ui.shadcn.com/">shadcn&#x2F;ui</a></li><li><a href="https://tailwindui.com/">Tailwind UI - Official Tailwind CSS Components &amp; Templates</a></li><li><a href="https://nextui.org/">NextUI - Beautiful, fast and modern React UI Library</a></li></ul><p>上面这些框架都是基于 <code>TailwindCSS</code> 这个 CSS 框架实现的 UI 组件库。并且都是可以用于学习 UI&#x2F;UX，并且是可以直接上手使用在生产项目中的。</p><p>比如 <code>from</code> 表单，shadcn ui 就有现成的 <code>TailwindCSS</code> 代码可用。<a href="https://ui.shadcn.com/docs/components/form">React Hook Form - shadcn&#x2F;ui</a>。这些也是我后面构建前端项目的基础。</p><h3 id="其他的-UI-组件库"><a href="#其他的-UI-组件库" class="headerlink" title="其他的 UI 组件库"></a>其他的 UI 组件库</h3><p>也有不少 UI 组件库是不基于 <code>TailwindCSS</code> 的，国内比较出门的是下面两个 UI 组件库，也涉及到不少 <code>UI/UX</code> 方面的知识，是用来学习很好的资料</p><ol><li>蚂蚁团队出品的 UI 组件库。<a href="https://ant-design.antgroup.com/index-cn">Ant Design - 一套企业级 UI 设计语言和 React 组件库</a></li><li>由抖音前端与 UED 团队维护，易于定制的现代化设计系统，帮助设计师与开发者打造高质量产品。<a href="https://semi.design/zh-CN/">Semi Design</a></li></ol><h2 id="后端项目"><a href="#后端项目" class="headerlink" title="后端项目"></a>后端项目</h2><p><code>Next.js</code> 虽然是一个全栈的框架，但是我并不打算后端部分全部由 <code>Next.js</code> 实现，如果存在复杂的逻辑，还是由我熟悉的后端技术栈实现比较合适。瞄了一眼 <code>Spring Security</code>，但是实在这周也没有太多时间完整看完，之后再说。</p><p>简单浏览了一下 Java 9 ~ Java 21 的新的语言特性，除了底层 <code>GC</code>，虚拟线程之类的优化，我并没有发现太多语言层面的变动，下周梳理下我觉得可以使用语法层面的语言特性。</p><h2 id="玩具项目"><a href="#玩具项目" class="headerlink" title="玩具项目"></a>玩具项目</h2><p>等学完上面这些部分之后，我可能会想构建一个简单的用户论坛。包含用户认证，发帖，评论。三块主要的功能。实践一下前后端的能力。详细的 PRD 让 AI 帮我输出了一份。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">创建一个用户论坛的产品需求文档（PRD）是一个复杂的过程，需要考虑多个方面，包括功能需求、用户体验、技术实现等。以下是一份详细的用户论坛的PRD概要：</span><br><span class="line">-</span><br><span class="line">用户论坛产品需求文档（PRD）</span><br><span class="line">1.引言</span><br><span class="line">1.1 目的</span><br><span class="line">本文档旨在详细描述用户论坛产品的功能和性能需求，为开发、测试和项目管理提供依据。</span><br><span class="line">1.2 背景</span><br><span class="line">随着互联网技术的发展，用户对于在线交流和信息共享的需求日益增长。用户论坛作为一个在线平台，允许用户发布帖子、评论和互动，是满足这一需求的有效工具。</span><br><span class="line">1.3 定义</span><br><span class="line">• 用户认证（Authentication）：验证用户身份的过程。</span><br><span class="line">• 授权（Authorization）：确定用户是否有权限执行特定操作的过程。</span><br><span class="line">• 帖子（Post）：用户在论坛上发表的主题内容。</span><br><span class="line">• 评论（Comment）：用户对帖子的回复或讨论。</span><br><span class="line">2.总体描述</span><br><span class="line">2.1 产品视角</span><br><span class="line">用户论坛将提供一个平台，让用户能够创建账户、发布帖子、评论他人帖子，并与其他用户互动。</span><br><span class="line">2.2 产品功能</span><br><span class="line">• 用户注册与登录</span><br><span class="line">• 帖子发布与管理</span><br><span class="line">• 评论发布与管理</span><br><span class="line">• 用户个人资料管理</span><br><span class="line">• 论坛管理与版主功能</span><br><span class="line">2.3 用户类和特征</span><br><span class="line">• 普通用户：需要注册、登录、发帖、评论和查看论坛内容。</span><br><span class="line">• 版主：除了普通用户的功能外，还需要管理帖子和评论，如删除不当内容。</span><br><span class="line">2.4 操作环境</span><br><span class="line">• 技术栈：Spring Boot（后端），React/Vue（前端），PostgreSQL（数据库）。</span><br><span class="line">• 支持的浏览器：最新版本的Chrome、Firefox、Safari。</span><br><span class="line">• 支持的设备：桌面和移动设备。</span><br><span class="line">2.5 设计和实现约束</span><br><span class="line">• 系统应支持至少1000个并发用户。</span><br><span class="line">• 数据应每24小时备份一次。</span><br><span class="line">2.6 用户文档</span><br><span class="line">提供用户手册和在线帮助文档。</span><br><span class="line">3.具体需求</span><br><span class="line">3.1 用户认证</span><br><span class="line">• 3.1.1 注册</span><br><span class="line">• 用户可以通过电子邮件注册账户。</span><br><span class="line">• 必须验证电子邮件地址。</span><br><span class="line">• 3.1.2 登录</span><br><span class="line">• 用户可以通过用户名和密码登录。</span><br><span class="line">• 提供忘记密码功能。</span><br><span class="line">3.2 帖子管理</span><br><span class="line">• 3.2.1 发帖</span><br><span class="line">• 用户可以创建新帖子。</span><br><span class="line">• 帖子应包含标题和内容。</span><br><span class="line">• 3.2.2 查看帖子</span><br><span class="line">• 用户可以查看所有帖子列表。</span><br><span class="line">• 用户可以查看单个帖子的详细内容。</span><br><span class="line">• 3.2.3 编辑和删除帖子</span><br><span class="line">• 用户可以编辑和删除自己的帖子。</span><br><span class="line">3.3 评论管理</span><br><span class="line">• 3.3.1 发布评论</span><br><span class="line">• 用户可以在帖子下发布评论。</span><br><span class="line">• 评论应包含内容。</span><br><span class="line">• 3.3.2 查看评论</span><br><span class="line">• 用户可以查看帖子的所有评论。</span><br><span class="line">• 3.3.3 编辑和删除评论</span><br><span class="line">• 用户可以编辑和删除自己的评论。</span><br><span class="line">3.4 用户个人资料</span><br><span class="line">• 3.4.1 个人资料编辑</span><br><span class="line">• 用户可以编辑自己的个人资料。</span><br><span class="line">• 包括头像、昵称、个人简介等。</span><br><span class="line">3.5 论坛管理</span><br><span class="line">• 3.5.1 帖子和评论审核</span><br><span class="line">• 版主可以删除不当的帖子和评论。</span><br><span class="line">• 版主可以锁定帖子，禁止进一步评论。</span><br><span class="line">3.6 性能需求</span><br><span class="line">• 3.6.1 响应时间</span><br><span class="line">• 页面加载时间不超过2秒。</span><br><span class="line">• 帖子和评论提交响应时间不超过1秒。</span><br><span class="line">3.7 安全需求</span><br><span class="line">• 3.7.1 数据加密</span><br><span class="line">• 用户密码必须加密存储。</span><br><span class="line">• 敏感数据传输必须使用HTTPS。</span><br><span class="line">3.8 国际化和本地化</span><br><span class="line">• 3.8.1 多语言支持</span><br><span class="line">• 论坛界面应支持至少英语和中文。</span><br><span class="line">4.文档和培训</span><br><span class="line">4.1 用户文档</span><br><span class="line">提供在线帮助文档和FAQ。</span><br><span class="line">4.2 培训</span><br><span class="line">为版主提供在线培训材料。</span><br><span class="line">5.交付和部署</span><br><span class="line">5.1 交付</span><br><span class="line">• 交付内容包括源代码、数据库脚本、配置文件和部署指南。</span><br><span class="line">5.2 部署</span><br><span class="line">• 提供详细的部署指南，包括环境设置、依赖安装和启动服务。</span><br><span class="line">6.质量保证</span><br><span class="line">6.1 测试</span><br><span class="line">• 包括单元测试、集成测试和性能测试。</span><br><span class="line">6.2 验证</span><br><span class="line">• 确保所有功能按预期工作，并满足性能需求。</span><br><span class="line">-</span><br><span class="line">请注意，这只是一个概要，每个部分都需要根据实际项目需求进一步细化。实际的PRD可能需要包含更多的细节，如界面设计、数据模型、API规范等。此外，PRD应该是一个活文档，随着项目进展可能需要更新和修改。</span><br></pre></td></tr></table></figure><p>这方面，AI 还是比较有优势的。至于说 AI 代码编辑器，比如 <code>Cursor</code> 和 <code>Windsurf</code>，之后可能也会尝试一下效果。一方面会想实践一个玩具项目，测试一下工程的能力。另一方面会想使用 AI 构建类似的项目，测试下 AI 构建项目的能力。</p><h2 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h2><p><code>Next.js</code> 是 <code>Vercel</code> 推出的 <code>React</code> 框架，在此之上，还提供了完整的网站托管的能力。如果完全不想部署自己的服务，是可以通过 <code>Vercel</code> 的免费流量，先部署一个可用的项目的。</p><p>此外，如果后端能力想要私有化部署，可以尝试下 <code>supabase</code>。一个 <code>Firebase</code> 的开源替代产品。</p><p>我按照官网 <code>docker compose</code> 搭建了一下，比较成功。之后再尝试 <code>supabase</code> 提供的能力吧。</p><style>.kyexnhqtmmml{zoom:25%}</style><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>我有看到 <code>pigsty</code> 这个项目，包装了不少 <code>postgres</code> 的扩展能力，并且也提供的 <code>supabase</code> 的部署教程，尝试跟着教程在云服务商 <code>vultr</code> 提供的虚拟机上部署了一下，很花费时间，至少一个小时起步吧。最终也没能在 <code>8000</code> 端口看到启动成功的 <code>supabase</code> 控制台。</p><p>另外，后面尝试使用官方的 <code>docker compose</code>。我原本是通过 <code>colima</code> 安装的 <code>docker</code> 和 <code>docker compose</code>，但是在创建外部 volume 时会报错，权限拒绝。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: error <span class="keyword">while</span> creating mount <span class="built_in">source</span> path <span class="string">&#x27;path&#x27;</span> : <span class="built_in">chown</span> path : permission denied</span><br></pre></td></tr></table></figure><p>切换到 podman 也同样存在问题，猜测的原因是 <code>colima</code> 和 <code>podman</code> 都是通过虚拟机启动，所以存在上面的问题。参考链接 <a href="https://stackoverflow.com/questions/45764477/docker-compose-error-while-creating-mount-source-path">Docker compose error while creating mount source path - Stack Overflow</a> <code>Snap</code> 安装的 docker 存在同样的问题。</p><p>最后，切换到官方提供的 docker macOS Desktop 解决了这个问题。非常浪费时间，今天的几个小时都浪费在这个上面了。</p><p>并且在国内拉取 docker 镜像，网络环境实在是太差了。</p><h2 id="Roadmap-sh"><a href="#Roadmap-sh" class="headerlink" title="Roadmap.sh"></a>Roadmap.sh</h2><p><a href="https://roadmap.sh/frontend">Frontend Developer Roadmap: What is Frontend Development?</a></p><p>这个项目我在几年前就已经有看到过了，当时简单看了一下，并没有很在意，现在再看，还是很成熟的，前后端路线图确实可以实际操作。</p><h2 id="如何删除一个文件里的所有空行"><a href="#如何删除一个文件里的所有空行" class="headerlink" title="如何删除一个文件里的所有空行"></a>如何删除一个文件里的所有空行</h2><p>通过 <code>VS Code</code> 的 <code>RegExp</code> 的替换功能就可以。<code>^$\n</code></p><p><a href="https://stackoverflow.com/questions/50042278/visual-studio-code-remove-blank-lines-from-code">Visual Studio Code - Remove blank lines from code - Stack Overflow</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这周做的事情非常杂乱，这里看一点，那里学一点。什么都懂一点，什么都没有精通。</p><p>微信公众号排版工具，在没有找到好用的工具之前，在线工具凑合用着。</p><p><a href="https://markdown.com.cn/editor">在线markdown编辑器_微信公众号markdown排版工具</a>​</p><h2 id="有趣的项目-文章"><a href="#有趣的项目-文章" class="headerlink" title="有趣的项目&#x2F;文章"></a>有趣的项目&#x2F;文章</h2><ul><li><p><a href="https://github.com/akazwz/extract">akazwz&#x2F;extract: 一个使用 Cloudflare 浏览器渲染功能从任何网站提取图片的现代 Web 应用。基于 Remix 构建并部署在 Cloudflare Pages 上。</a></p></li><li><p><a href="https://wompa.land/articles/docker-cheatsheet-2025">The Ultimate Docker Command Cheatsheet and Guide for 2025 – wompa.land</a></p></li><li><p><a href="https://www.creative-tim.com/twcomponents/cheatsheet/">Tailwind CSS Cheat Sheet</a></p></li><li><p><a href="https://becomesovran.com/blog/server-setup-basics.html">Server Setup Basics</a></p></li><li><p><a href="https://blog.huli.tw/2022/05/23/atomic-css-and-tailwind-css/">淺談 Atomic CSS 的發展背景與 Tailwind CSS - Huli’s blog</a></p></li><li><p><a href="https://nextjs-book.innei.in/reading/guide/0.what-this">这是什么小册 | 聊点不一样的 Next.js</a></p></li><li><p><a href="https://relationship.ohevan.com/">一个自以为是的情感指南</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广来这周在做什么 001</title>
      <link href="/what-is-guanglai-doing-this-week-001/"/>
      <url>/what-is-guanglai-doing-this-week-001/</url>
      
        <content type="html"><![CDATA[<p>这是广来这周在做些什么的第一期，主要的内容就是我这一周在做的事情，会分享一些生活、工作、技术相关的事情。</p><p>在写作之前，我想起来一句话，但是只能通过搜索得到，大致是 Leslie Lamport 说的一句：</p><blockquote><p>如果你在没有写下来的情况下思考，那你只是「以为」自己在思考。</p></blockquote><span id="more"></span><p>我已经有很长一段时间没有写作了。或者说，我几乎没有写作的能力。一直以来，我对自己的写作能力都不怎么看好，所以也有些逃避写作。写不好，所以不想写。但是不去写，当然永远也都写不好。所以，开始写吧，即使写得很差劲。</p><p>做技术相关工作的人似乎也都有些写作羞耻，觉得自己做的技术才是最重要的，大部分并不喜欢做分享，写作相关的工作。但是现在的时代是自媒体时代，我希望能够通过写作这种方式，将自己的想法分享出去，让更多的人认识到我。</p><p>过去的二十多年，已经接近三十年了，我都没有写作和记录的习惯。既不写作，也不会记录写什么，发在朋友圈和社交媒体上。回想过去的生活，只能通过手机里的零散照片回想起一丁点的细节。</p><p>总之，这是现在的我写给未来的我看的，也是写给大家看的。只是在写下这篇文章的当下，我并不会通过社交媒体分享。等到有足够的积累在做这件事情吧。</p><h2 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h2><p>我最近有在学习前端，工作以来做了四年多的后端，但是对于前端仍然是一知半解。作为一个后端开发，永远只知道编写接口，就觉得网站已经开发好了。在看到 Next.js 对于前端的介绍之前，我对于前端的理解程度还只是在 HTML + CSS + JS 这样的传统搭档，我知道 HTML 页面是如何呈现一个页面的，但是我不知道现代化的前端工具在这件事情里的角色。我了解 Node.js、Vue.js、React.js，但是并不知道这些前端框架在 Web 开发中扮演的角色。</p><p>在学习完成了 Next.js 的入门教程之后，我大致明白了现代化的前端工具在 Web 开发中的角色，知道了在前端工具里，也分为 Client 端和 Server 端。后面我会再写一篇文档详细聊聊这件事情。在了解了 Next.js 后，一个后端开发眼中的 Web 开发。</p><h2 id="出海建站"><a href="#出海建站" class="headerlink" title="出海建站"></a>出海建站</h2><p>我最近有在使用的社交媒体【即刻】，是我在发现【小红书】之后，第二个，还不错的了解咨询的网站。小红书一般用作生活百科搜索引擎和了解一些当下潮流文化的网站。在这个平台上了解到了还是【出海建站】这种赚钱的方式，对我来说算是新奇又不新奇的方式。一方面，我知道可以做网站，有流量，可以接入广告赚钱。另一方面，我确实没有想到会一大批人，出海做网站，并且能够真实收到美元作为收入。做网站这件事情对于一个工作了几年的后端开发来说，前端还不是最困难的方式，我主要觉得困难的方面，一是如果接入广告，二是广告或者用户支付的收益，如果接入支付方式获取真正可以在国内使用的收益。</p><p>国内做网站一大劣势就是需要域名备案，这太麻烦也太拖慢开发进度了。</p><p>另一方面，一大批人在使用 AI，有点子，就可以做出网站、APP，这点作为技术人员都难以想象。拥有一点点技术的人，对于产品，和实现产品的方式，眼光太过于局限。</p><p>这也是我学习前端的一个很重要的原因。我也许可以通过 AI 辅助创建网站，但是如果后续需要维护，还是需要真的了解当前的前端工作。以及，我确实想做一些足够有用的网站。接下来我的业余时间会有一部分花在这个上面。</p><p>这也是我三十岁 Fire 老板的一个基石吧。技术人员想要持续性的收入无外乎写作、独立 APP、独立网站。写作和 APP 我都不占优势、先从独立网站开始吧。</p><h2 id="开放平台文档"><a href="#开放平台文档" class="headerlink" title="开放平台文档"></a>开放平台文档</h2><p>几乎每家足够大的公司都会有自己的开放平台，有开放平台就会有开放平台文档。我现在工作的公司也有开放平台和开放平台文档，只是文档的质量一言难尽，很是糟糕。我最近工作上被调组到了一个刚起步的海外项目的组，有在对标海外某一公司的产品做设计，在开放平台实现和文档上也都有所借鉴，借着这个机会，我也大致了解了下 Shopify 和 GitHub 的开放平台文档的部分标准，我比较感兴趣的是分页这一部分，很有意思。这两者的分页标准是开放平台级别的标准，对比我司，几乎还只是接口级别的。分页这类列表接口的统一能力，作为平台级别的标准，我认为是十分合适的。</p><p>在技术实现上，海外公司似乎也极为相似。有兴趣的朋友可以看看。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章写的实际上是我最近有在做的事情，并不全是这周在做的事情。不过因为是第一次开始写周刊，汇总一些最近有在做的事情也并不奇怪。就是这样，下周再见。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://nextjs.org/learn/react-foundations/what-is-react-and-nextjs">React Foundations: About React and Next.js | Next.js</a></li><li><a href="https://shopify.dev/docs/api/admin-rest/usage/pagination">Make paginated requests to the REST Admin API</a></li><li><a href="https://docs.github.com/en/rest/using-the-rest-api/using-pagination-in-the-rest-api?apiVersion=2022-11-28">Using pagination in the REST API - GitHub Docs</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升级 Hexo 和对应的主题 NexT Theme 的版本</title>
      <link href="/update-hexo-7-x-and-theme-next-8-x/"/>
      <url>/update-hexo-7-x-and-theme-next-8-x/</url>
      
        <content type="html"><![CDATA[<p>最近准备重新捡起很久没写的博客，在浏览器里打开博客页面，发现博客页面的样式文件已经丢失，就像年久失修的房屋一样。想要重新开始写博客，首要的是升级下博客使用的静态页面模板。</p><span id="more"></span><p>以下命令行操作，如果没有特殊描述，都是在博客文件夹根目录下执行。</p><h2 id="升级-Hexo-版本"><a href="#升级-Hexo-版本" class="headerlink" title="升级 Hexo 版本"></a>升级 Hexo 版本</h2><p>思路：主要先升级 <code>node.js</code> 和 <code>hexo-cli</code> 的版本，其次借助 <code>npm</code> 相关工具包的能力，更新 <code>hexo</code> 下依赖的部分 <code>npm</code> 包的版本，主要是插件部分。</p><ol><li>升级 <code>node.js</code> 版本。v12 -&gt; v14</li></ol><p>由于我使用的是 <code>nvm</code> 管理 <code>node.js</code> 的相关版本，直接使用 <code>nvm use</code> 即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install v14</span><br><span class="line">nvm use v14</span><br></pre></td></tr></table></figure><ol start="2"><li>升级 <code>hexo-cli</code> 版本。</li></ol><p>或者卸载重新安装 <code>hexo-cli</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ol start="3"><li>更新 <code>npm</code> 插件</li></ol><p>安装工具包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check</span><br><span class="line">npm install -g npm-upgrade</span><br></pre></td></tr></table></figure><p>升级 <code>npm</code> 依赖，按照提示升级对应插件的版本即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm-check</span><br><span class="line">npm-upgrade</span><br><span class="line">npm update -g</span><br></pre></td></tr></table></figure><h2 id="升级-Next-Theme-版本"><a href="#升级-Next-Theme-版本" class="headerlink" title="升级 Next Theme 版本"></a>升级 Next Theme 版本</h2><p>老版的 <code>hexo</code> 安装主题是直接把主题拉取放到 <code>theme</code> 目录下，自从 <code>5.0</code> 版本之后，支持通过 <code>npm</code> 包的方式安装主题。所以我删除了原本的 <code>theme</code> 主题，通过 <code>npm</code> 安装了最新版本的 NexT Theme。</p><p>NexT Theme 文档：</p><blockquote><p>If you’re using Hexo 5.0 or later, the simplest way to install is through npm:</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure><p>新版的主题配置文件，博客根目录下 <code>_config.next.yml</code>。<br>至此，基本上的版本升级就完成了。不过由于版本跨度的原因，我没有保留原有的 NexT 的配置文件，而是直接在配置现有的主题配置文件。</p><h2 id="博客本地图片链接修复"><a href="#博客本地图片链接修复" class="headerlink" title="博客本地图片链接修复"></a>博客本地图片链接修复</h2><p>老版本依赖 <code>hexo-asset-image</code> 提供引用本地相对路径图片的能力，以使用原生 Markdown 渲染，自从 <code>Hexo 5</code> 版本后，该插件就失效了，所以使用 <code>hexo-asset-img</code> 插件替换。</p><p>卸载 <code>hexo-asset-image</code> 插件，安装 <code>hexo-asset-img</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-asset-image --save</span><br><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><p>不过实际尝试之后，发现 <code>about</code> 页面的图片仍然无法展示，暂时先搁置该问题了。</p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><ol><li><p>域名服务商处配置 DNS <code>CANME</code> 记录。</p></li><li><p>添加 <code>CNAME</code> 文件<br>Github Pages 提供了自动域名的能力，不过由于 Hexo 每次部署都是重新推送文件到 Github 仓库，所以在设置中配置自定义域名会被覆盖，解决办法是在 <code>source</code> 文件夹下添加文件名为 <code>CNAME</code> 的文件即可。</p></li></ol><p>Hexo 的文档中提到：</p><blockquote><p>若你使用了一个带有 CNAME 的自定义域名，你需要在 source&#x2F; 文件夹中新增 CNAME 文件。</p></blockquote><p>文件内容示例，以我的域名为例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blog.guanglai.me</span><br></pre></td></tr></table></figure><h2 id="谷歌网站验证"><a href="#谷歌网站验证" class="headerlink" title="谷歌网站验证"></a>谷歌网站验证</h2><p>在启用 Google Search Consloe 提交网站收录时，需要验证网站所有权，Google 给的其中之一的方式是在网站首页添加 HTML 标记。</p><style>.tpkkfqkwllco{zoom:25%}</style><p>在 NexT 的配置文件中 _config.next.yml 配置如下内容，配置对应 token 即可。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">google_site_verification:</span> <span class="string">your_token</span></span><br></pre></td></tr></table></figure><h2 id="图片缩放"><a href="#图片缩放" class="headerlink" title="图片缩放"></a>图片缩放</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./picture-in-hexo/test.jpg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;图片标题&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;没有加载时显示的内容&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:25%&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-alt is-center&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>图片标题2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="特殊配置"><a href="#特殊配置" class="headerlink" title="特殊配置"></a>特殊配置</h2><ul><li>sitemap 开启站点地图，方便搜索引擎 SEO</li><li>local search 提供简单的本地搜索功能</li><li>utterances 替换 gitalk，作为博客评论插件</li><li>mathjax LaTeX 语法的数学公式支持</li><li>post edit 可以直接在对应的 Github 仓库源文件修改，搭配 Github Action 可以在修改后自动发布</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://leimingshan.com/posts/d9017f30/">Hexo升级指南 | Mingshan Lei’s Blog</a></li><li><a href="https://github.com/next-theme/hexo-theme-next">NexT theme</a></li><li><a href="https://github.com/yiyungent/hexo-asset-img">yiyungent&#x2F;hexo-asset-img: 🍰 Hexo local image plugin. | Hexo 本地图片插件: 转换 图片相对路径 为 asset_img</a></li><li><a href="https://utteranc.es/">utterances</a></li><li><a href="https://hexo.io/zh-cn/docs/github-pages">在 GitHub Pages 上部署 Hexo | Hexo</a></li><li><a href="https://www.cnblogs.com/ywang-wnlo/p/Hexo-SEO.html">【Hexo】配置主流搜索引擎收录流程记录 - ywang_wnlo - 博客园</a></li><li><a href="http://home.ustc.edu.cn/~sdyzzy/posts/36e27ee1.html">在 hexo 中使用图片的几种方法 | SDYZZY’s Universe</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> NexT Theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 147 链表的插入排序</title>
      <link href="/leetcode-147-Insertion-Sort-List/"/>
      <url>/leetcode-147-Insertion-Sort-List/</url>
      
        <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Sort a linked list using insertion sort.<br>Algorithm of Insertion Sort:</p><ol><li>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</li><li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.</li><li>It repeats until no input elements remain.</li></ol></blockquote><span id="more"></span><p>单链表的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想法：</p><p>使用两条链表，一条是已经有序的链表 A，一条是待排序的链表 B。将节点从待排序的链表 B 依次插入已经有序的链表 A。</p><p>关键点在于想到使用两条链表。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">insertionSortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line"></span><br><span class="line">        ListNode fakeHead= <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// because we need insert before head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; <span class="comment">// current node will be insert</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// previous node of insert node</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// next node of current insert node</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// save next position</span></span><br><span class="line">            next = cur.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// find insert position</span></span><br><span class="line">            pre = fakeHead;</span><br><span class="line">            <span class="keyword">while</span> (pre.next != <span class="literal">null</span> &amp;&amp; pre.next.val &lt; cur.val) &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert cur between pre and pre.next</span></span><br><span class="line">            cur.next = pre.next;</span><br><span class="line">            pre.next = cur;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// move point forward</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Online Judge </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Docker 创建 MySQL 实验环境</title>
      <link href="/create-a-mysql-lab-using-docker/"/>
      <url>/create-a-mysql-lab-using-docker/</url>
      
        <content type="html"><![CDATA[<p>由于有学习 MySQL 的需求，但是又不想破坏本地的 MySQL(MariaDB)，于是想到了使用 Docker 来创建符合需求的 MySQL 实验环境。<br>并且通过官方(?)提供的测试数据创建用于测试使用的数据库。</p><p>本文默认读者已安装好 Docker 及本地 MySQL。</p><span id="more"></span><h2 id="拉取已有的-MySQL-Docker-镜像。"><a href="#拉取已有的-MySQL-Docker-镜像。" class="headerlink" title="拉取已有的 MySQL Docker 镜像。"></a>拉取已有的 MySQL Docker 镜像。</h2><p>使用下面的命令搜索可用的 mysql：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p>可以看到类似下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   8621                [OK]</span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   2997                [OK]</span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   637                                     [OK]</span><br><span class="line">centos/mysql-57-centos7           MySQL 5.7 SQL database server                   63</span><br></pre></td></tr></table></figure><p>使用下面的命令拉取第一个官方镜像的最新版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><h2 id="创建并运行-Docker-容器中的-MySQL"><a href="#创建并运行-Docker-容器中的-MySQL" class="headerlink" title="创建并运行 Docker 容器中的 MySQL"></a>创建并运行 Docker 容器中的 MySQL</h2><p>使用下面的命令运行和配置刚刚拉取的 Docker 镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql-lab -p 3307:3306 -e MYSQL_ROOT_PASSWORD=password -d mysql</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>--name TEXT</code> 表示创建的镜像的名称，如果不提供该参数，则 docker 会随机生成一个名称。该示例中创建的名称为 mysql-lab</li><li><code>-e TEXT</code> 表示提供的环境变量的键值对。此处提供一个名为 MYSQL_ROOT_PASSWORD 的环境变量，其值为 password</li><li><code>-d</code> 表示在后台运行该容器</li><li><code>-p</code> 指定容器外端口到容器内端口的映射，3307 为容器外端口，3306 为容器内端口，即 MySQL 默认运行端口。指定后，即可在容器外通过 <code>localhost</code> 地址加上 3307 端口连接到容器内的 MySQL。就如同操作本地安装的 MySQL 一样，而不需要进行下方的容器外连接 MySQL 的操作。</li></ul><h2 id="检查容器的运行状态"><a href="#检查容器的运行状态" class="headerlink" title="检查容器的运行状态"></a>检查容器的运行状态</h2><p>使用下面的命令检查：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>可以类似下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                           NAMES</span><br><span class="line">c046b3491396        mysql               &quot;docker-entrypoint.s…&quot;   4 hours ago         Up 4 hours          3306/tcp, 33060/tcp                             mysql-lab</span><br></pre></td></tr></table></figure><h2 id="连接-Docker-中的-MySQL"><a href="#连接-Docker-中的-MySQL" class="headerlink" title="连接 Docker 中的 MySQL"></a>连接 Docker 中的 MySQL</h2><ul><li><p>直接进入容然后进入 MySQL 命令行</p><p>  可以使用下面的命令直接进入 Docker 容器中然后连接该容器中的 MySQL：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql-lab bash</span><br></pre></td></tr></table></figure><p>  进入容器后，和在本地中使用类似，使用下面的命令即可进入 MySQL 命令行:</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>  密码为先前设置的 <code>password</code></p></li><li><p><del>从容器外连接 MySQL</del> <strong>可直接指定端口映射从容器外连接 MySQL</strong></p><p>  更好的方法是在容器外连接 MySQL。</p><ol><li>首先使用下面的命令查找出刚刚创建的 Docker 镜像的地址：</li></ol>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect mysql-lab | grep IPAddress</span><br></pre></td></tr></table></figure><p>  可以看到如下的输出：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;IPAddress&quot;: &quot;172.17.0.2&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据刚刚查找出的地址连接 MySQL 数据库</li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h 172.17.0.2 -P 3306 -p</span><br></pre></td></tr></table></figure></li></ul><h2 id="导入测试数据"><a href="#导入测试数据" class="headerlink" title="导入测试数据"></a>导入测试数据</h2><ol><li><p>下载测试数据</p><p> <a href="https://github.com/datacharmer/test_db">测试数据地址</a></p></li><li><p>按照地址中的 <code>README</code> 进行操作即可。下方操作只导入了数据库模型，并未导入实际的数据。且指定端口后不再需要类似下方的操作。</p></li><li><p>进入到下载的测试数据的目录下</p></li><li><p>导入到数据库中</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h 172.17.0.2 -P 3306 -p &lt; employees.sql</span><br></pre></td></tr></table></figure></li><li><p>测试导入的数据完整性</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h 172.17.0.2 -P 3306 -p -t &lt; test_employees_md5.sql</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Hexo + GitHub 搭建博客</title>
      <link href="/hexo-and-github-build-blog/"/>
      <url>/hexo-and-github-build-blog/</url>
      
        <content type="html"><![CDATA[<p>因为不止有一个同学问过我如何借助 GitHub 搭建博客，是决定把搭建博客的整个流程记录下来，<br>以供想要自己借助 Hexo 和 GitHub 搭建博客的同学参考。<br>我主要使用 Hexo 生成静态站点文件，然后　push 到 GitHub 上借助 GitHub Pages 展示静态博客。</p><span id="more"></span><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>在安装 <code>Hexo</code> 之前，首先需要先安装 <code>Node.js</code> 和 <code>Git</code>。</p><ol><li>安装 <code>Node.js</code> 和　<code>Npm</code></li></ol><ul><li>最简单的方式就是到 <a href="https://nodejs.org/en/download/">Node.js download page</a> 直接下载安装。</li></ul><ol start="2"><li>安装并配置 Git</li></ol><ul><li><p>安装 Git</p><p>  到 <a href="https://git-scm.com/downloads">Git Download page</a> 根据所用的操作系统下载并安装 Git</p></li><li><p>配置 Git</p><p>  在使用 Git 之前，需要先配置 Git 的用户名和用户邮箱</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email youremail@example.com</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>安装 Hexo</p><p> 使用 Npm 安装 Hexo。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用-Hexo"><a href="#使用-Hexo" class="headerlink" title="使用 Hexo"></a>使用 Hexo</h2><p>使用下面的命令初始化目标文件夹，所有需要的文件都会被下载到该文件夹下。<br>这个过程需要一段时间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>初始化之后就可使用如下命令预览，默认已经有一篇 Hello World 文档用于预览效果的展示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>可以看到命令行有提示，Hexo 运行在地址 <a href="http://localhost:4000/">http://localhost:4000</a>，通过浏览器打开该网址即可看到预览结果。</p><h2 id="博客编写"><a href="#博客编写" class="headerlink" title="博客编写"></a>博客编写</h2><p>所有的文档的编写都需要放在 <code>source/_posts</code> 目录下，初始化后可以看到该目录下有一个 <code>hello-world.md</code>，同样，我们需要写的文档也类似。</p><p>简单使用 <a href="https://www.markdownguide.org/basic-syntax">Markdown 的指导</a></p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><ol><li><p>在你的 GitHub 账户下创建一个仓库用于存放 Hexo 生成的静态文件。GitHub Page 会根据仓库名给定一个对应的域名。假定用户名为 username，规则如下:</p><ol><li>如果仓库名为 <code>username.github.io</code>，则对应的域名为 <code>username.github.io</code></li><li>如果是其他名字，如 <code>theBlogRepository</code>，则对应的域名为 <code>username.github.io/theblogrepository</code></li></ol><p> 比如，我的 GitHub 用户名为 <a href="https://github.com/KnothHe">knothhe</a>，我存放博客的仓库名为 <code>blog</code>，我的博客地址就是 <a href="https://knothhe.github.io/blog">https://knothhe.github.io/blog</a>。</p><p> 最后在该仓库的设置页面需要开启 GitHub Page 的选项，默认有 master 分支和 master 分支下的 &#x2F;docs 文件夹。选择 master 分支即可。</p></li><li><p>配置 <code>_config.yml</code></p><ul><li>可以看到该文件默认有 deploy 小节，由于是发布到 GitHub，那么按下面配置编写即可:</li></ul> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span></span><br><span class="line">        <span class="attr">github:</span> <span class="string">git@github.com:yourGitHubUsername/theBlogRepository.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p>安装 Hexo 使用 Git 发布的插件</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>使用下面的命令发布到你的 GitHub 仓库</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d g</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>详细的使用和指导可以参考 <a href="https://hexo.io/docs/">Hexo 的文档</a>。</p><p>已经有很多人写过类似的文章了，通过 google 或者 baidu 搜索下面的关键词即可得到很多的详细教程。</p><p>搜索关键字: <code>hexo github 个人博客</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><code>Git</code> 官网的<a href="https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup">配置指导</a></li><li><code>Git</code> 官网的<a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">安装指导</a></li><li><code>Npm</code> 官网的<a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm#os-x-or-windows-node-installers">安装指导</a></li><li><code>Hexo</code> 官网的<a href="https://hexo.io/docs/index.html">安装指导</a></li><li><code>Hexo</code> 官网的<a href="https://hexo.io/docs/setup">使用指导</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX 实现简单的条件编译</title>
      <link href="/latex-conditional-compilation/"/>
      <url>/latex-conditional-compilation/</url>
      
        <content type="html"><![CDATA[<p>我想让 LaTeX 支持的条件编译的功能是：</p><p>根据我是否定义某个具体的宏变量，决定是否编译某一片段。</p><p>通过简单搜索之后，了解到一个简单的宏包 <code>ifthen</code> 即可实现此功能，现将实现方法记录如下。</p><span id="more"></span><p>TLDR:</p><ol><li>引入 <code>ifthen</code> 宏包。</li><li>使用 <code>\ifthenelse&#123;\isundefine&#123;\themarco&#125;&#125;&#123;〈then clause〉&#125;&#123;〈else clause〉</code> 命令</li><li>通过 <code>xelatex &quot;\def\themarco&#123;1&#125; &quot;\input&#123;filename.tex&#125;&quot;</code> 在编译时定义宏。</li></ol><h2 id="引入-ifthen-宏包"><a href="#引入-ifthen-宏包" class="headerlink" title="引入 ifthen 宏包"></a>引入 <code>ifthen</code> 宏包</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;ifthen&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-ifthenelse"><a href="#使用-ifthenelse" class="headerlink" title="使用 \ifthenelse{}{}{}"></a>使用 <code>\ifthenelse&#123;&#125;&#123;&#125;&#123;&#125;</code></h2><p>根据文档，　<code>\ifthenelse&#123;〈test〉&#125;&#123;〈then clause〉&#125;&#123;〈else clause〉</code>　的定义如下：</p><p>如果 test 为真，则包括 <code>&lt;then clause&gt;</code>，否则包括 <code>&lt;else clause&gt;</code>。</p><p><code>&lt;test&gt;</code> boolean 表达式可以以 <code>\and</code>、<code>\or</code>、<code>\not</code> 连接，此处我只需要测试一个宏是否定义，则不需要。</p><p>文档中还写到，可以使用 <code>\isundefined&#123;&#125;</code> 来测试一个具体的宏是否未定义。虽然我更想找到一个宏可以判断一个变量是否被定义，但是，好吧，这个宏也能完成我需要的功能。</p><p>所以，完成的语句如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\ifthenelse</span>&#123;<span class="keyword">\isundefined</span>&#123;<span class="keyword">\themacro</span>&#125;&#125;&#123;</span><br><span class="line">    &lt;then clause&gt;</span><br><span class="line">&#125;&#123;</span><br><span class="line">    &lt;else clause&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果　<code>\themacro</code> 未定以，则执行（包括） <code>&lt;then clause&gt;</code>，否则执行 <code>&lt;else clause&gt;</code>。</p><p>至此，在 <code>tex</code> 文档中需要做的工作已经完成。接下来我们需要知道的是如何使用命令行编译时定义某个具体的宏。幸好，这个问题也很好解决。</p><h2 id="在使用编译命令时定义具体的宏"><a href="#在使用编译命令时定义具体的宏" class="headerlink" title="在使用编译命令时定义具体的宏"></a>在使用编译命令时定义具体的宏</h2><p>以 <code>xelatex</code> 为例，我们可以直接输入以下命令编译指定文件。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex filename.tex</span><br></pre></td></tr></table></figure><p>同时如果输入参数不是文件名，而是字符串的话，同样可以编译。即 <code>xelatex &quot;string&quot;</code> 同样可以通过编译并生成文件，默认的文件名是 <code>texput.pdf</code>。目前，我仍然不知道 <code>xelatex</code> 如何指定输出文件名。</p><p>于是，我们可以通过以下命令定义我们需要的宏。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex &quot;<span class="keyword">\def</span><span class="keyword">\thenmarco</span>&#123;1&#125; <span class="keyword">\input</span>&#123;filename.tex&#125;&quot;</span><br></pre></td></tr></table></figure><p>至此，我所需要的条件编译的功能得到满足。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://mirrors.ctan.org/macros/latex/base/ifthen.pdf">ifthen 宏包文档</a></li><li><a href="https://tex.stackexchange.com/a/1495">如何通过命令行定义 LaTeX 变量的 SO 回答</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广州百田 2019 笔试题</title>
      <link href="/guangzhou-baitian-written-test/"/>
      <url>/guangzhou-baitian-written-test/</url>
      
        <content type="html"><![CDATA[<p>趁着秋招，因为同学的推荐，投递了广州百田。这两天百田发送邮件，通知线上笔试。内容摘要如下：</p><blockquote><p>百奥（广州百田）邀请您参加线上笔试，试卷名称是： 开发工程师-百奥2020届校园招聘笔试（笔试题根据网申岗位而定）<br>请务必在试卷开放时间 2019-09-21 9:00:00 至 2019-09-23 21:00:00 完成答卷，<br>请复制下方的试卷链接到浏览器中作答。（Web前端、游戏前端、Java后端开发均为同一套题）<br>(链接地址)<br>祝福：信心是成功的一半，祝您考试顺利！</p></blockquote><p>笔试题总共有三道，都是非常基础的题目，现记录如下。</p><span id="more"></span><p>注 1: 百田笔试题给定的某些题目描述是 C++，某些是 Java，而且答题语言不限。<br>我提供的题目和答案则都是 C++ 描述。</p><p>注 2: 在和同学讨论后，我们一致认为百田的线上笔试有漏洞。首先，和同学讨论过后得知，我们的测试题目相同。</p><p>从发送的邮件内容：</p><blockquote><p>（Web前端、游戏前端、Java后端开发均为同一套题）</p></blockquote><p>也可得知，统一批次的线上笔试题应该相同。那么如果有两个认识的人参加同一轮线上笔试，<br>并且在不同时间点做题，那么先做的那个人就可以知道题目，然后就可以告知后做的人。<br>那么，后做题的人就可先行准备。因为我和同学是同时开始答题，则无法利用此漏洞。<br>当然，我们也并不打算利用此漏洞，只是觉得有必要说明一下。</p><p>注 3: 貌似不同批次的题目是不一样的，所以只有同一批次的应聘者的笔试题目才是相同的。<br>所以为什么不把笔试时间固定，而是在一个时间范围内？</p><h2 id="分割链表"><a href="#分割链表" class="headerlink" title="分割链表"></a>分割链表</h2><p>假定有一个链表，编写一个函数，将该按如下规则分成三个链表。</p><p>首先，给定的节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">char</span> content;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，规则如下：</p><ol><li>如果该节点的 content 为大写字母，则插入第一条链表。</li><li>如果该节点的 content 为数字，则插入第二条链表。</li><li>其他则插入第三条链表。</li></ol><p>最后，需要完成的函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;Node*&gt; <span class="title">split</span><span class="params">(Node *head)</span></span>;</span><br></pre></td></tr></table></figure><p>题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;Node*&gt; <span class="title">split</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;Node*&gt; <span class="title">curs</span><span class="params">(<span class="number">3</span>, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;Node*&gt; <span class="title">heads</span><span class="params">(<span class="number">3</span>, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line">    Node *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node *next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> c = cur-&gt;content;</span><br><span class="line">        <span class="type">int</span> which = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            which = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            which = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curs[which] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            curs[which] = cur;</span><br><span class="line">            heads[which] = curs[which];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curs[which]-&gt;next = cur;</span><br><span class="line">            curs[which] = curs[which]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">char</span> content;</span><br><span class="line">    Node *next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">char</span> c) : <span class="built_in">content</span>(c), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_nodes</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    Node *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; cur-&gt;content;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;A233CD@#SD2&quot;</span>;</span><br><span class="line">    Node *head = <span class="keyword">new</span> <span class="built_in">Node</span>(s[<span class="number">0</span>]);</span><br><span class="line">    Node *cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">Node</span>(s[i]);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;Node*&gt; curs = <span class="built_in">split</span>(head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; curs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">print_nodes</span>(curs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h2><p>注： 题目给定的应该是 Java 形式的函数定义，为 <code>void shuffle(int[] orderArray)</code></p><p>给定一个数组，打乱该数组。</p><p>需要完成的函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="type">int</span>&gt; orderArray)</span></span>;</span><br></pre></td></tr></table></figure><p>提供一个生成随机数的函数 <code>rand(min, max)</code> 返回值为 <code>[min, max)</code> 之间的一个整数。</p><p>题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;orderArray)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = orderArray.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">rand</span>(i, len);</span><br><span class="line">        <span class="type">int</span> t = orderArray[r];</span><br><span class="line">        orderArray[r] = orderArray[i];</span><br><span class="line">        orderArray[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rand(min, max) rand() % (max - min) + min</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">orderArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; orderArray.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        orderArray[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shuffle</span>(orderArray);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; orderArray.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; orderArray[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算前缀表达式的值"><a href="#计算前缀表达式的值" class="headerlink" title="计算前缀表达式的值"></a>计算前缀表达式的值</h2><p>给定一个以前缀表达式表示的字符串，计算其结果。</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-*+1234</span><br></pre></td></tr></table></figure><p>等价于下面的中缀表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 + 2) * 3 - 4</span><br></pre></td></tr></table></figure><p>其结果为 5。</p><p>给定的函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">eval</span><span class="params">(string exp)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">eval</span><span class="params">(string exp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = exp.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">char</span> c = exp[i];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> b = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> r;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    r = a + b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    r = a - b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    r = a * b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (1 + 2) * 3 - 4 = 5</span></span><br><span class="line">    string exp = <span class="string">&quot;-*+1234&quot;</span>;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">calc</span>(exp);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="number">5</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;test pass\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;test fail\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p><strong>题目解析等之后再弄，今天有点晚了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下 VS Code 的 C/C++ 调试器使用</title>
      <link href="/vscode-linux-debugger-launch/"/>
      <url>/vscode-linux-debugger-launch/</url>
      
        <content type="html"><![CDATA[<p>一直以来，我在 Linux 下的 VS Code 的启动调试器都存在无法调试需要获取用户输入的程序，昨天总算是把这个问题解决了。</p><p>tldr: 在 Linux 下不要用 lldb，用 gdb，具体原因不清楚，但是我被坑了。</p><span id="more"></span><h2 id="launch-json-和-task-json"><a href="#launch-json-和-task-json" class="headerlink" title="launch.json 和 task.json"></a>launch.json 和 task.json</h2><p>VS Code 下启动调试器需要依赖文件夹根目录下的 .vsocde&#x2F;launch.json 文件，该目录及其子目录的调试器的行为都可以通过在该文件中配置选项来指定。最简单的创建 launch.json 文件的方法是在需要调试的源程序标签页中点击左边 Activity Bar 上的调试器的按钮，当没有 launch.json 文件时，VS Code 会提示根据模板创建 launch.json 文件。然后回到源程序标签下，启动刚刚创建的 launch.json，由于没有生成可调试的可执行文件，需要生成 .vscode&#x2F;task.json 预先编译源文件生成可调试的可执行文件。正常情况下，接下来应该就可以进行调试。但是在 Manjaro 下使用是我遇到了以下问题。</p><h2 id="externalConsole-选项-默认外部终端的坑"><a href="#externalConsole-选项-默认外部终端的坑" class="headerlink" title="externalConsole 选项&#x2F;默认外部终端的坑"></a>externalConsole 选项&#x2F;默认外部终端的坑</h2><p>根据 vscode-cpptools 的这个 <a href="https://github.com/microsoft/vscode-cpptools/issues/2998">issue</a> 中线索，当设置 externalConsole 为 true 时，在 Linux 下，调试器会完全无法启动。设置为 false，则可以启动，但是无法获用户输入（后来证实是我遇到的另一个坑）。</p><p>仔细阅读该 issue 可以发现，关键在于 VS Code 的调试器在启动时，如果该选项设置为 true，则 VS Code 会根据 terminal.external.linuxExec 推断在 Linux 下应该启动的默认的 Terminal，并且该选项的默认值为 xterm。但是我的系统上并没有安装 xterm，所以在启动调试器后一直卡顿在这一步。于是安装 xterm。然后调试器正常启动。</p><h2 id="gdb-vs-lldb"><a href="#gdb-vs-lldb" class="headerlink" title="gdb vs lldb"></a>gdb vs lldb</h2><p>开始时我使用的调试器是 lldb，一切都很正常，唯有在读取用户输入时，无论是内部终端还是外部终端，都无法成功。于是切换到 gdb，成功。从这儿就能感觉到 llvm 在 Linux 下的支持还是不如 gcc，虽然我很喜欢或者说更偏向 clang&#x2F;llvm。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有意思的是，我刚刚引用的那个 issue 是唯一被标记的 issue，可见被坑的人应该不在少数 ;p</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS Code </tag>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Debugger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IEEE 浮点数表示</title>
      <link href="/ieee-floating-point-representation/"/>
      <url>/ieee-floating-point-representation/</url>
      
        <content type="html"><![CDATA[<p>一直以来都不能非常清楚地记住浮点数的表示方式，这段时间开始重读 CSAPP 的第二章中浮点数表示的部分，大致上弄清楚了 IEEE 浮点数的表示方式。</p><p>简单介绍一下 IEEE 浮点数的表示方式，细节部分可以参考 CSAPP 和 <a href="https://en.wikipedia.org/wiki/IEEE_754">维基</a></p><span id="more"></span><h2 id="二进制小数表示"><a href="#二进制小数表示" class="headerlink" title="二进制小数表示"></a>二进制小数表示</h2><p>首先理解一下十进制小数的表示方式，我们以下面这种方式表示十进制小数：</p><p>$$<br>    d_{n}d_{n-1}…d_{1}d_{0}.d_{-1}…d_{m}<br>$$</p><p>表示的值为：</p><p>$$<br>    \sum_{i &#x3D; m}^{n} 10^{i}d_{i}<br>$$</p><p>类似地，二进制小数的表示方式：</p><p>$$<br>    b_{n}b_{n-1}…b_{1}b_{0}.b_{-1}…b_{m}<br>$$</p><p>$$<br>    \sum_{i &#x3D; m}^{n} 2^{i}b_{i}<br>$$</p><p>例如二进制小数</p><p>$$<br>11.01_2 &#x3D; 1 \times 2^{1} + 1 \times 2^{0} + 0 \times 2^{-1} + 1 \times 2^{-2}<br>    &#x3D; 2 + 1 + 0 + 0.25<br>    &#x3D; 3.25<br>$$</p><p>现在考虑如何对这种二进制小数进行编码，一种可行的方式是定点小数。即将小数点的位置固定。例如使用 16 位二进制数来编码定点小数。可以做如下规定：</p><ol><li>第 15 位为符号位。</li><li>第 14 ~ 9 位表示小数点前的数</li><li>第 8 ~ 0 位表示小数点后的数</li></ol><p>那么，$11.01$ 可以编码为 $0 000011 010000000$。</p><p>这种表示方式的优点是比较简单，但是能够表示的小数的范围就十分的小。不考虑小数点后的数字，这种方式能够表示的整数范围就只能是 $-2^{6}+1 \sim 2^{6} - 1$。</p><p>于是，考虑到不去固定小数点的位置。而是根据当前的数字来确定小数点的具体位置。这样，就有了一种新的表示小数的方式，即浮点数。以下面这种方式表示（不考虑编码方式）：</p><p>$$<br>    V &#x3D; (-1)^s \times M \times 2^{E}<br>$$</p><p>其中，$s$ 表示符号位，$E$ 表示阶码，$M$ 表示尾数。</p><p>通过这种方式，就有了 IEEE 754 浮点数规范。其具体定义了浮点数的位级编码规则。</p><h2 id="IEEE-浮点数表示"><a href="#IEEE-浮点数表示" class="headerlink" title="IEEE 浮点数表示"></a>IEEE 浮点数表示</h2><p>首先， IEEE 将浮点数编码为 32 位或者 64 位。其中，32 位的规则如下：</p><ol><li>第 32 位表示符号</li><li>第 31 ~ 23 位表示的值为 $E$，其位级表示记为 $exp$</li><li>第 22 ~ 0 位表示的值 $M$, 其位级表示记为 $frac$</li></ol><p>64 位编码表示中，$exp$ 长度为 11，$frac$ 长度为 52。与 32 位类似。</p><p>根据 $exp$ 和 $frac$ 的表示的不同，IEEE 浮点数规范将浮点数分为 4 类：</p><ol><li>规格化数： $exp$ 不为全 0 和全 1</li><li>非规格化数： $exp$ 为全 0</li><li>无穷大： $exp$ 为全 1 且 $frac$ 为全 0</li><li>$NAN$： $exp$ 为全 1 且 $frac$ 不为全 0</li></ol><h3 id="规格化数"><a href="#规格化数" class="headerlink" title="规格化数"></a>规格化数</h3><p>首先 $E &#x3D; e - Bias$, 其中 $e$ 为 $exp$ 所表示的无符号数。$Bias$ 的值为 $2^{k-1}-1$，$k$ 为 $frac$ 部分的长度。例如，32 位编码时 $k$ 的值为 $8$，于是 $Bias$ 的值为 $127$，最终， $E$ 的范围为 $-126 \sim 127$。</p><p>其次 $M &#x3D; 1 + f$，其中 $f$ 为 $0.f_{n}f_{n-1}…f_{0}$ 所表示的值。这里，通过将 $f$ 加 1 获得了一个额外的表示精度位。</p><h3 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h3><p>其 $E &#x3D; 1 - Bias$，而 $M &#x3D; f$。</p><p>根据该定义，当 $frac$ 为全 0 时， $M &#x3D; 0$。于是：</p><p>$$<br>    V &#x3D; (-1)^s \times E \times 0 &#x3D; 0<br>$$</p><p>根据 $s$ 的值的不同，得到了表示 0 的两种方式，记为 $+0$ 和 $-0$。</p><h3 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h3><p>根据符号位分为 $+\infty$ 和 $-\infty$。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，非规格化数用于表示 $0$ 和非常接近 $0$ 的数。而相对其他能正常表示的数则用规格化数表示，溢出的值则用无穷大表示。当溢出的小数部分为非 $0$ 即可用 $NAN$（Not A Number)表示。当一些运算的结果不是实数或者无穷时，就会返回 $NAN$，比如 $\sqrt{-1}$。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>写技术文章需要严谨、正确，可能我比没有做到。所有如果有疑惑的话，可以学习一下 CSAPP 中和此有关的内容。</p><!-- 我后悔写这篇博客了，描述好一个规范并不是一件容易的事。想要讲的正确且生动就更加不容易了。但是因为已经写了，于是还是决定放出来。以后如果再打算写类似的博客一定会仔细考虑考虑。而且，实际上 CSAPP 上的这一小节讲述的已经足够清楚了。 -->]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IEEE 754 </tag>
            
            <tag> Floating Point </tag>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初次笔试题</title>
      <link href="/interview-first-time/"/>
      <url>/interview-first-time/</url>
      
        <content type="html"><![CDATA[<p>昨天参加了学校的一个企业实习的宣讲会，结束后做了笔试题。签到时我选择的应聘岗位是后端开发，但是在选择笔试试卷是选择了 C&#x2F;C++ 开发。和编程相关的题目总共是 4 道题。现场做题的时候有很多的细节没有考虑到，而且我更习惯使用电脑写代码，没有多少在纸上写代码的经历，最后只写了 3 道，一道空白。就个人感觉，这些笔试题中有一道题并不适合笔试。最后，最重要的是很基础的题目我并没有能够做到 bug-free。编程的基础还需要继续巩固。特记录如下。</p><span id="more"></span><p>题目记录如下：</p><h2 id="C-语言-strcat-的实现"><a href="#C-语言-strcat-的实现" class="headerlink" title="C 语言 strcat 的实现"></a>C 语言 <code>strcat</code> 的实现</h2><p>和库函数 <code>strcat</code> 并不相同，声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span></span><br></pre></td></tr></table></figure><p>大致的思路是先计算出 a 和 b 的长度，然后根据 a 和 b 的长度计算出需要分配给返回字符串的内存空间的大小，最后将 a 和 b 的内容依次拷贝到返回字符串中。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">strcat_m</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> aLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; a[aLen] != <span class="string">&#x27;\0&#x27;</span>; ++aLen) &#123;</span><br><span class="line">        ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b[bLen] != <span class="string">&#x27;\0&#x27;</span>; ++bLen) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = aLen + bLen;</span><br><span class="line">    <span class="type">char</span>* str = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len+<span class="number">1</span>));</span><br><span class="line">    <span class="type">char</span>* p = str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; aLen; ++i) &#123;</span><br><span class="line">        *p = a[i];</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bLen; ++i) &#123;</span><br><span class="line">        *p = b[i];</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">10</span>] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">10</span>] = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *str = strcat_m(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表逆序"><a href="#链表逆序" class="headerlink" title="链表逆序"></a>链表逆序</h2><p>这个是对链表操作的基础的考察。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node* head;</span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">helper</span><span class="params">(Node* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* n = p-&gt;next;</span><br><span class="line">        n = helper(n);</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            n-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(LinkedList* li)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* head = li-&gt;head;</span><br><span class="line">    Node* h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (h-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* last = helper(head);</span><br><span class="line">        last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    li-&gt;head = h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinkedList</span><span class="params">(LinkedList* li)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* p = li-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;ch);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkedList* li;</span><br><span class="line">    li-&gt;head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    li-&gt;head-&gt;ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    li-&gt;head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Node* p = li-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Node* t = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        t-&gt;ch = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">        t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printLinkedList(li);</span><br><span class="line">    reverse(li);</span><br><span class="line">    printLinkedList(li);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码写完之后，我想到的是如果可以使用栈的话，只要先将所有节点压入栈，在弹出节点指针的过程中，先将第一个出栈的节点记录为头节点，之后依次链接，最后一个节点链接 <code>NULL</code>，这样程序的逻辑就会更加简单，缺点就是引入了额外的数据结构。</p><p>当然，上述的递归代码也是隐式地使用了函数调用栈。</p><p>如果使用三个指针的话，就可以不使用栈完成链表逆序。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(LinkedList* li)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* prev = <span class="literal">NULL</span>, *cur = li-&gt;head, *next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = prev;</span><br><span class="line">    li-&gt;head = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>这道题就是我觉得不应该出现在面试题中的题目。快排的话，会和不会都是在笔试之前就已经确定了的，并且并不太能体现处应试者的编程（算法）水平。毕竟，没有多少人会没事写个快排。</p><p>虽说如此，还是写了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> beg, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = beg;</span><br><span class="line">    ++beg;</span><br><span class="line">    <span class="keyword">while</span> (beg &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (vec[beg] &lt;= vec[p] &amp;&amp; beg &lt;= end) &#123;</span><br><span class="line">            ++beg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (vec[end] &gt;= vec[p] &amp;&amp; end &gt;= beg) &#123;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(vec[beg], vec[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(vec[p], vec[end]);</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> beg, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beg &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">partition</span>(vec, beg, end);</span><br><span class="line">    <span class="built_in">helper</span>(vec, beg, p<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">helper</span>(vec, p<span class="number">+1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">helper</span>(vec, <span class="number">0</span>, vec.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVec</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;v : vec) &#123;</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span> ,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">printVec</span>(vec);</span><br><span class="line">    <span class="built_in">quicksort</span>(vec);</span><br><span class="line">    <span class="built_in">printVec</span>(vec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的步骤就是三步：</p><ol><li>切分</li><li>递归排序前半部分</li><li>递归排序后半部分</li></ol><p>最后，需要注意递归终止的条件。</p><p>这三步中最重要的就是切分这一步。</p><h2 id="要求打印出汉诺塔的移动序列"><a href="#要求打印出汉诺塔的移动序列" class="headerlink" title="要求打印出汉诺塔的移动序列"></a>要求打印出汉诺塔的移动序列</h2><p>最初接触到这道题是我大二开始学习计算机算法最初接触递归的时候。再次碰到的时候只考虑到了移动次数，内心觉得移动序列可能比较麻烦，就没再考虑。笔试时也没有多加思考就放弃了。</p><p>在回宿舍的路上大致想明白了思路：</p><ol><li>递归打印 <code>N-1</code></li><li>打印 <code>N</code></li><li>递归打印 <code>N-1</code></li></ol><p>没有考虑到的是需要将 <code>A B C</code> 三个柱子看作三个区域，目标是将整个汉诺塔依照要求从 <code>A</code> 移动到 <code>C</code>。这就需要考虑每一步移动时将 <code>A B C</code> 分别看作是 <code>源(from)</code>、<code>缓冲区(buffer)</code> 和 <code>目的(to)</code>。这部分参考 <a href="https://zh.wikipedia.org/zh-hans/%E6%B1%89%E8%AF%BA%E5%A1%94#%E9%81%9E%E8%BF%B4%E8%A7%A3">wiki</a>。</p><p>思路：</p><ol><li>递归将 <code>N-1</code> 从 <code>from</code> 以 <code>to</code> 为缓冲区移动到 <code>buffer</code></li><li>将 <code>N</code> 从 <code>from</code> 移动到 <code>to</code></li><li>递归将 <code>N-1</code> 从 <code>buffer</code> 以 <code>from</code> 为缓冲区移动到 <code>to</code></li></ol><p>关键代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helper(N<span class="number">-1</span>, from, to, buffer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Move disk %d from %c to %c\n&quot;</span>, N, from, to);</span><br><span class="line">helper(N<span class="number">-1</span>, buffer, from, to);</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span> N, <span class="type">char</span> from, <span class="type">char</span> buffer, <span class="type">char</span> to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    helper(N<span class="number">-1</span>, from, to, buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Move disk %d from %c to %c\n&quot;</span>, N, from, to);</span><br><span class="line">    helper(N<span class="number">-1</span>, buffer, from, to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hannoi</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    helper(N, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_hannoi(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    print_hannoi(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    print_hannoi(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次笔试没经验。我的基础能力也还是不足。离开电脑写代码，水平就开始极速下降了。</p><p>这家公司的 C&#x2F;C++ 工程师的 4 道笔试题中有三道是需要用到递归实现的……</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX Beamer 使用</title>
      <link href="/use-latex-beamer/"/>
      <url>/use-latex-beamer/</url>
      
        <content type="html"><![CDATA[<p>今天用了 Beamer 做一个 Presentation，花了一点时间在查找各种细节。 Presentation 已经基本完成。于是决定把折腾得到的结果记录一下。</p><p>以下均是一个 <code>LaTeX</code> 门外汉的个人见解，也只是知其然而不知其所以然罢了。</p><p>最终的 <a href="https://github.com/KnothHe/Markup-Files/blob/master/beamer/c51-beamer.tex">Presentation</a></p><span id="more"></span><h2 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h2><p>可以添加一些作者，日期之类的信息。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;..&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">\data</span>&#123;...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="标题页"><a href="#标题页" class="headerlink" title="标题页"></a>标题页</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;frame&#125;</span><br><span class="line">    <span class="keyword">\titlepage</span></span><br><span class="line"><span class="keyword">\end</span>&#123;frame&#125;</span><br></pre></td></tr></table></figure><h2 id="生成-ToC"><a href="#生成-ToC" class="headerlink" title="生成 ToC"></a>生成 ToC</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;frame&#125;&#123;Table of Contents&#125;</span><br><span class="line">    <span class="keyword">\tableofcontents</span></span><br><span class="line"><span class="keyword">\end</span>&#123;frame&#125;</span><br></pre></td></tr></table></figure><h2 id="Frame-标题"><a href="#Frame-标题" class="headerlink" title="Frame 标题"></a>Frame 标题</h2><p>在 <code>frame</code> 后加上 <code>&#123;title&#125;</code> 就行了。建议每个 <code>frame</code> 都加上一个标题。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;frame&#125;&#123;Title of This Frame&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;frame&#125;</span><br></pre></td></tr></table></figure><h2 id="中文显示"><a href="#中文显示" class="headerlink" title="中文显示"></a>中文显示</h2><p>这个问题在我刚开始使用 <code>LaTeX</code> 是还是挺犯难的，用的时间较长了，加上多年来 <code>LaTeX</code> 的发展， LaTeX 对非西文字体的支持已经发展的相对友好，解决方法已经变得相当的简单。</p><p>简单的解决方法就是使用 xeCJK，并配置中文字体。参考 <a href="https://liam.page/2014/11/02/latex-mactex-chinese-support/">为 MacTeX 配置中文支持</a></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;xeCJK&#125;</span><br><span class="line"><span class="keyword">\setCJKmainfont</span>[BoldFont=STZhongsong, ItalicFont=STKaiti]&#123;STSong&#125;</span><br><span class="line"><span class="keyword">\setCJKsansfont</span>[BoldFont=STHeiti]&#123;STXihei&#125;</span><br><span class="line"><span class="keyword">\setCJKmonofont</span>&#123;STFangsong&#125;</span><br></pre></td></tr></table></figure><p>中文字体可简单使用 <code>\usepackage&#123;ctex&#125;</code></p><p>并且对于中文等非西文字体的 <code>.tex</code> 源文件编译时，优先采用 <code>XeLaTeX</code>。毕竟原本 <code>XeTeX/XeLaTeX</code> 原本的设计目的就是增强对非西文字体的支持。</p><h2 id="Beamer-主题"><a href="#Beamer-主题" class="headerlink" title="Beamer 主题"></a>Beamer 主题</h2><p>我比较喜欢的主题是 <code>CambridgeUS</code></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usetheme</span>&#123;CambridgeUS&#125;</span><br></pre></td></tr></table></figure><p>挑选 Beamer 内置主题的话，可以参考 <a href="https://hartwork.org/beamer-theme-matrix/">Beamer Theem Matrix</a> 或者 <a href="https://mpetroff.net/files/beamer-theme-matrix/">Another Beamer Theme Matrix</a> </p><p>当然，在主题之上还可以修改 <code>colortheme</code> 之类的。我挺喜欢正在使用的主题的默认的 <code>colortheme</code> 的，也就没改。</p><h2 id="划分章节"><a href="#划分章节" class="headerlink" title="划分章节"></a>划分章节</h2><p>和普通的 <code>LaTeX</code> 文档类似，可以为 <code>Beamer</code> 添加章节信息。章节信息最后会用于生成目录。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\section</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="代码排版"><a href="#代码排版" class="headerlink" title="代码排版"></a>代码排版</h2><p>在一个 <code>frame</code> 中排版代码也是可以的，借助 <code>listings</code> 宏包的解决方法如下：</p><p>下面这一部分可定义也可不定义，参考（复制于） <a href="https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings">WikiBooks</a></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;color&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\definecolor</span>&#123;mygreen&#125;&#123;rgb&#125;&#123;0,0.6,0&#125;</span><br><span class="line"><span class="keyword">\definecolor</span>&#123;mygray&#125;&#123;rgb&#125;&#123;0.5,0.5,0.5&#125;</span><br><span class="line"><span class="keyword">\definecolor</span>&#123;mymauve&#125;&#123;rgb&#125;&#123;0.58,0,0.82&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\lstset</span>&#123; </span><br><span class="line">    backgroundcolor=<span class="keyword">\color</span>&#123;white&#125;,   <span class="comment">% choose the background color; you must add \usepackage&#123;color&#125; or \usepackage&#123;xcolor&#125;; should come as last argument</span></span><br><span class="line">    basicstyle=<span class="keyword">\ttfamily</span><span class="keyword">\footnotesize</span>,        <span class="comment">% the size of the fonts that are used for the code</span></span><br><span class="line">    breakatwhitespace=true,         <span class="comment">% sets if automatic breaks should only happen at whitespace</span></span><br><span class="line">    breaklines=true,                 <span class="comment">% sets automatic line breaking</span></span><br><span class="line">    captionpos=b,                    <span class="comment">% sets the caption-position to bottom</span></span><br><span class="line">    commentstyle=<span class="keyword">\color</span>&#123;mygreen&#125;,    <span class="comment">% comment style</span></span><br><span class="line">    deletekeywords=&#123;...&#125;,            <span class="comment">% if you want to delete keywords from the given language</span></span><br><span class="line">    escapeinside=&#123;<span class="keyword">\%</span>*&#125;&#123;*)&#125;,          <span class="comment">% if you want to add LaTeX within your code</span></span><br><span class="line">    extendedchars=true,              <span class="comment">% lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8</span></span><br><span class="line">    frame=single,                   <span class="comment">% adds a frame around the code</span></span><br><span class="line">    keepspaces=false,                 <span class="comment">% keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)</span></span><br><span class="line">    morekeywords=&#123;bit, sbit, sfr, sfr16&#125;,            <span class="comment">% if you want to add more keywords to the set</span></span><br><span class="line">    keywordstyle=<span class="keyword">\color</span>&#123;blue&#125;,       <span class="comment">% keyword style</span></span><br><span class="line">    language=C,                 <span class="comment">% the language of the code</span></span><br><span class="line">    numbers=left,                    <span class="comment">% where to put the line-numbers; possible values are (none, left, right)</span></span><br><span class="line">    numbersep=5pt,                   <span class="comment">% how far the line-numbers are from the code</span></span><br><span class="line">    numberstyle=<span class="keyword">\tiny</span><span class="keyword">\color</span>&#123;mygray&#125;, <span class="comment">% the style that is used for the line-numbers</span></span><br><span class="line">    rulecolor=<span class="keyword">\color</span>&#123;black&#125;,         <span class="comment">% if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))</span></span><br><span class="line">    showspaces=false,                <span class="comment">% show spaces everywhere adding particular underscores; it overrides &#x27;showstringspaces&#x27;</span></span><br><span class="line">    showstringspaces=false,          <span class="comment">% underline spaces within strings only</span></span><br><span class="line">    showtabs=false,                  <span class="comment">% show tabs within strings adding particular underscores</span></span><br><span class="line">    <span class="comment">%  stepnumber=2,                    % the step between two line-numbers. If it&#x27;s 1, each line will be numbered</span></span><br><span class="line">    stringstyle=<span class="keyword">\color</span>&#123;mymauve&#125;,     <span class="comment">% string literal style</span></span><br><span class="line">    tabsize=2,                 <span class="comment">% sets default tabsize to 2 spaces</span></span><br><span class="line">    title=<span class="keyword">\lstname</span>                   <span class="comment">% show the filename of files included with \lstinputlisting; also try caption instead of title</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这部分参考 <a href="https://tex.stackexchange.com/questions/36776/latex-error-when-inserting-code-listing-in-lyx">StackExchange</a>。</p><p>就是在需要排版代码的 <code>frame</code> 后加上参数 <code>fragile</code>。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;frame&#125;[fragile]</span><br><span class="line">    <span class="keyword">\begin</span>&#123;lstlisting&#125;[language=...]</span><br><span class="line">        <span class="comment">% ...</span></span><br><span class="line">        <span class="comment">% CODE</span></span><br><span class="line">        <span class="comment">% ...</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;lstlisting&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;frame&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> Beamer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 语法支持测试</title>
      <link href="/markdown-syntax-support-test/"/>
      <url>/markdown-syntax-support-test/</url>
      
        <content type="html"><![CDATA[<p>Markdown 语法支持的测试博文，有关 Markdown 的语法可参考 <a href="https://www.markdownguide.org/basic-syntax">Markdown Guide</a></p><span id="more"></span><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li><strong>粗体</strong></li><li><em>斜体</em></li><li><em><strong>粗体和斜体</strong></em></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p></blockquote><h2 id="代码块及代码高亮"><a href="#代码块及代码高亮" class="headerlink" title="代码块及代码高亮"></a>代码块及代码高亮</h2><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><h3 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转义标记"><a href="#转义标记" class="headerlink" title="转义标记"></a>转义标记</h2><p>比如　<code>LaTeX</code></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="有内容的链接"><a href="#有内容的链接" class="headerlink" title="有内容的链接"></a>有内容的链接</h3><p><a href="https://www.markdownguide.org/basic-syntax">Markdown Guide</a></p><h3 id="无内容的链接-URL-和-Email"><a href="#无内容的链接-URL-和-Email" class="headerlink" title="无内容的链接(URL 和 Email)"></a>无内容的链接(URL 和 Email)</h3><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p><a href="https://blog.guanglai.me/blog">https://blog.guanglai.me/blog</a></p><h4 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h4><p><a href="mailto:&#103;&#x75;&#x61;&#110;&#x67;&#108;&#x61;&#x69;&#x68;&#x65;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;">&#103;&#x75;&#x61;&#110;&#x67;&#108;&#x61;&#x69;&#x68;&#x65;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><h3 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h3><p>质能方程：$E &#x3D; mc^2$</p><h3 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h3><p>黎曼 $\zeta$ 函数</p><p>$$<br>    \zeta(s) &#x3D; \sum_{n&#x3D;1}^{\infty} \frac{1}{n^s}<br>$$</p><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p><a href="https://raw.githubusercontent.com/KnothHe/blog/master/source/_posts/markdown-syntax-support-test.md">地址</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
